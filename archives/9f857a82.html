<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Redis面试篇 | Norlcyan's Blog</title><meta name="author" content="Zhao"><meta name="copyright" content="Zhao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Redis主从单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离 主从集群结构下图就是一个简单的Redis主从集群结构：     搭建主从集群在同一个虚拟机中利用3个Docker容器来搭建主从集群，容器信息如下：    容器名 角色 IP 映射端口    r1 master 192.168.150.101 7001   r2 slave 192">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis面试篇">
<meta property="og:url" content="http://example.com/archives/9f857a82.html">
<meta property="og:site_name" content="Norlcyan&#39;s Blog">
<meta property="og:description" content="Redis主从单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离 主从集群结构下图就是一个简单的Redis主从集群结构：     搭建主从集群在同一个虚拟机中利用3个Docker容器来搭建主从集群，容器信息如下：    容器名 角色 IP 映射端口    r1 master 192.168.150.101 7001   r2 slave 192">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/avatar.jpg">
<meta property="article:published_time" content="2026-01-16T08:00:14.000Z">
<meta property="article:modified_time" content="2026-01-16T08:07:06.832Z">
<meta property="article:author" content="Zhao">
<meta property="article:tag" content="后端">
<meta property="article:tag" content="非关系型数据库">
<meta property="article:tag" content="集群">
<meta property="article:tag" content="面试相关">
<meta property="article:tag" content="缓存问题">
<meta property="article:tag" content="内存回收">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/avatar.jpg"><link rel="shortcut icon" href="/img/z.png"><link rel="canonical" href="http://example.com/archives/9f857a82.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis面试篇',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2026-01-16 16:07:06'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/footer.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/bodybg.css"><meta name="generator" content="Hexo 7.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">92</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">142</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fa fa-comments"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Norlcyan's Blog"><span class="site-name">Norlcyan's Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fa fa-comments"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Redis面试篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2026-01-16T08:00:14.000Z" title="发表于 2026-01-16 16:00:14">2026-01-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2026-01-16T08:07:06.832Z" title="更新于 2026-01-16 16:07:06">2026-01-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Redis面试篇"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="Redis主从"><a href="#Redis主从" class="headerlink" title="Redis主从"></a>Redis主从</h1><p>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离</p>
<h2 id="主从集群结构"><a href="#主从集群结构" class="headerlink" title="主从集群结构"></a>主从集群结构</h2><p>下图就是一个简单的Redis主从集群结构：</p>
<img src="/img/loading.gif" data-original="/img/微服务assests/1280X1280 (4).PNG" alt="1280X1280 (4)" style="zoom:80%;" />



<h2 id="搭建主从集群"><a href="#搭建主从集群" class="headerlink" title="搭建主从集群"></a>搭建主从集群</h2><p>在同一个虚拟机中利用3个Docker容器来搭建主从集群，容器信息如下：</p>
<table>
<thead>
<tr>
<th align="left"><strong>容器名</strong></th>
<th align="left"><strong>角色</strong></th>
<th align="left"><strong>IP</strong></th>
<th align="left"><strong>映射端口</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">r1</td>
<td align="left">master</td>
<td align="left">192.168.150.101</td>
<td align="left">7001</td>
</tr>
<tr>
<td align="left">r2</td>
<td align="left">slave</td>
<td align="left">192.168.150.101</td>
<td align="left">7002</td>
</tr>
<tr>
<td align="left">r3</td>
<td align="left">slave</td>
<td align="left">192.168.150.101</td>
<td align="left">7003</td>
</tr>
</tbody></table>
<h3 id="启动多个Redis实例"><a href="#启动多个Redis实例" class="headerlink" title="启动多个Redis实例"></a>启动多个Redis实例</h3><p>利用课前资料提供的docker-compose文件来构建主从集群：</p>
<p><img src="/img/loading.gif" data-original="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1assests/ce41d630-bc2e-4f6f-aaa6-ee8912341a22.png" alt="ce41d630-bc2e-4f6f-aaa6-ee8912341a22"></p>
<p>文件内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">r1:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:6.2.7</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">r1</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line">    <span class="attr">entrypoint:</span> [<span class="string">&quot;redis-server&quot;</span>, <span class="string">&quot;--port&quot;</span>, <span class="string">&quot;7001&quot;</span>]</span><br><span class="line">  <span class="attr">r2:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:6.2.7</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">r2</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line">    <span class="attr">entrypoint:</span> [<span class="string">&quot;redis-server&quot;</span>, <span class="string">&quot;--port&quot;</span>, <span class="string">&quot;7002&quot;</span>]</span><br><span class="line">  <span class="attr">r3:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:6.2.7</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">r3</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line">    <span class="attr">entrypoint:</span> [<span class="string">&quot;redis-server&quot;</span>, <span class="string">&quot;--port&quot;</span>, <span class="string">&quot;7003&quot;</span>]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意1：视频中用的redis镜像是latest，目前镜像版本已更新，需要将docker-compose.yaml的redis镜像版本设置为6.2.7</p>
<p>注意2：搭建Redis集群时，网络模式需要为”host”（不通过网桥&#x3D;&gt;宿主机网络的流程，而是直接连接到宿主机网络上）</p>
</blockquote>
<p>将其上传至虚拟机的<code>/root/redis</code>目录下，执行命令，运行集群：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker compose up -d</span><br></pre></td></tr></table></figure>



<p>查看docker容器，发现都正常启动了：</p>
<p><img src="/img/loading.gif" data-original="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1assests/b4e6b299-7669-4bf9-aff9-d522600357f1.png" alt="b4e6b299-7669-4bf9-aff9-d522600357f1"></p>
<p>由于采用的是host模式，看不到端口映射。不过能直接在宿主机通过ps命令查看到Redis进程：</p>
<p><img src="/img/loading.gif" data-original="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1assests/7c91b7e8-06ed-4802-afbb-673c6fcfda9e.png" alt="7c91b7e8-06ed-4802-afbb-673c6fcfda9e"></p>
<h3 id="建立集群"><a href="#建立集群" class="headerlink" title="建立集群"></a>建立集群</h3><p>虽然启动了3个Redis实例，但是它们并没有形成主从关系。需要通过命令来配置主从关系：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Redis5.0以前</span></span><br><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line"><span class="comment"># Redis5.0以后</span></span><br><span class="line">replicaof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure>



<p>有临时和永久两种模式：</p>
<ul>
<li>永久生效：在redis.conf文件中利用<code>slaveof</code>命令指定<code>master</code>节点</li>
<li>临时生效：直接利用redis-cli控制台输入<code>slaveof</code>命令，指定<code>master</code>节点</li>
</ul>
<p>测试临时模式，首先连接<code>r2</code>，让其以<code>r1</code>为master</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接r2</span></span><br><span class="line">docker <span class="built_in">exec</span> -it r2 redis-cli -p 7002</span><br><span class="line"><span class="comment"># 认r1主，也就是7001</span></span><br><span class="line">slaveof 192.168.150.101 7001</span><br></pre></td></tr></table></figure>



<p>然后连接<code>r3</code>，让其以<code>r1</code>为master</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接r3</span></span><br><span class="line">docker <span class="built_in">exec</span> -it r3 redis-cli -p 7003</span><br><span class="line"><span class="comment"># 认r1主，也就是7001</span></span><br><span class="line">slaveof 192.168.150.101 7001</span><br></pre></td></tr></table></figure>



<p>然后连接<code>r1</code>，查看集群状态：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接r1</span></span><br><span class="line">docker <span class="built_in">exec</span> -it r1 redis-cli -p 7001</span><br><span class="line"><span class="comment"># 查看集群状态</span></span><br><span class="line">info replication</span><br></pre></td></tr></table></figure>



<p>结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:7001&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=192.168.150.101,port=7002,state=online,offset=140,lag=1</span><br><span class="line">slave1:ip=192.168.150.101,port=7003,state=online,offset=140,lag=1</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:16d90568498908b322178ca12078114e6c518b86</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:140</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:140</span><br></pre></td></tr></table></figure>

<p>可以看到，当前节点<code>r1:7001</code>的角色是<code>master</code>，有两个slave与其连接：</p>
<ul>
<li><code>slave0</code>：<code>port</code>是<code>7002</code>，也就是<code>r2</code>节点</li>
<li><code>slave1</code>：<code>port</code>是<code>7003</code>，也就是<code>r3</code>节点</li>
</ul>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>依次在<code>r1</code>、<code>r2</code>、<code>r3</code>节点上执行下面命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> num 123</span><br><span class="line"></span><br><span class="line">get num</span><br></pre></td></tr></table></figure>

<p>可以发现只有在<code>r1</code>这个节点上可以执行<code>set</code>命令（<strong>写操作</strong>），其它两个节点只能执行<code>get</code>命令（<strong>读操作</strong>）。也就是说读写操作已经分离了。</p>
<h2 id="主从同步原理"><a href="#主从同步原理" class="headerlink" title="主从同步原理"></a>主从同步原理</h2><h3 id="全量同步"><a href="#全量同步" class="headerlink" title="全量同步"></a>全量同步</h3><p>主从第一次建立连接时，会执行<strong>全量同步</strong>，将master节点的所有数据都拷贝给slave节点，流程：</p>
<p><img src="/img/loading.gif" data-original="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1assests/5f021cbd-577a-4d25-8997-9773ff77272f.png" alt="5f021cbd-577a-4d25-8997-9773ff77272f"></p>
<p>这里有一个问题，<code>master</code>如何得知<code>salve</code>是否是第一次来同步呢？？</p>
<p>有几个概念，可以作为判断依据：</p>
<ul>
<li>**<code>Replication Id</code>**：简称<code>replid</code>，是数据集的标记，replid一致则是同一数据集。每个<code>master</code>都有唯一的<code>replid</code>，<code>slave</code>则会继承<code>master</code>节点的<code>replid</code></li>
<li>**<code>offset</code>**：偏移量，随着记录在<code>repl_baklog</code>中的数据增多而逐渐增大。<code>slave</code>完成同步时也会记录当前同步的<code>offset</code>。如果<code>slave</code>的<code>offset</code>小于<code>master</code>的<code>offset</code>，说明<code>slave</code>数据落后于<code>master</code>，需要更新</li>
</ul>
<p>因此<code>slave</code>做数据同步，必须向<code>master</code>声明自己的<code>replication id </code>和<code>offset</code>，<code>master</code>才可以判断到底需要同步哪些数据</p>
<p>由于在执行<code>slaveof</code>命令之前，所有redis节点都是<code>master</code>，有自己的<code>replid</code>和<code>offset</code></p>
<p>当第一次执行<code>slaveof</code>命令，与<code>master</code>建立主从关系时，发送的<code>replid</code>和<code>offset</code>是自己的，与<code>master</code>肯定不一致</p>
<p><code>master</code>判断发现<code>slave</code>发送来的<code>replid</code>与自己的不一致，说明这是一个全新的slave，就知道要做全量同步了</p>
<p><code>master</code>会将自己的<code>replid</code>和<code>offset</code>都发送给这个<code>slave</code>，<code>slave</code>保存这些信息到本地。自此以后<code>slave</code>的<code>replid</code>就与<code>master</code>一致了</p>
<p>因此，<strong>master判断一个节点是否是第一次同步的依据，就是看replid是否一致</strong>。流程如图：</p>
<p><img src="/img/loading.gif" data-original="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1assests/b774819c-631a-482d-adaf-080b81ecad3d.png" alt="b774819c-631a-482d-adaf-080b81ecad3d"></p>
<p>完整流程描述：</p>
<ul>
<li><code>slave</code>节点请求增量同步</li>
<li><code>master</code>节点判断<code>replid</code>，发现不一致，拒绝增量同步</li>
<li><code>master</code>将完整内存数据生成<code>RDB</code>，发送<code>RDB</code>到<code>slave</code></li>
<li><code>slave</code>清空本地数据，加载<code>master</code>的<code>RDB</code></li>
<li><code>master</code>将<code>RDB</code>期间的命令记录在<code>repl_baklog</code>，并持续将log中的命令发送给<code>slave</code></li>
<li><code>slave</code>执行接收到的命令，保持与<code>master</code>之间的同步</li>
</ul>
<p>来看下<code>r1</code>节点的运行日志：</p>
<p><img src="/img/loading.gif" data-original="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1assests/30f1f875-99c1-40c2-87e2-0cbf64f67160.png" alt="30f1f875-99c1-40c2-87e2-0cbf64f67160"></p>
<p>再看下<code>r2</code>节点执行<code>replicaof</code>命令时的日志：</p>
<p><img src="/img/loading.gif" data-original="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1assests/388a7e64-ef47-4348-9849-0516dce97084.png" alt="388a7e64-ef47-4348-9849-0516dce97084"></p>
<h3 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h3><p>全量同步需要先做RDB，然后<font color='red'>将RDB文件通过网络传输个slave，成本太高</font>了。因此除了第一次做全量同步，其它大多数时候slave与master都是做<strong>增量同步</strong></p>
<p>什么是增量同步？就是只更新slave与master存在差异的部分数据。如图：</p>
<p><img src="/img/loading.gif" data-original="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1assests/d359ffbc-514c-4058-ad5e-12926ae64531.png" alt="d359ffbc-514c-4058-ad5e-12926ae64531"></p>
<h4 id="repl-baklog原理"><a href="#repl-baklog原理" class="headerlink" title="repl_baklog原理"></a>repl_baklog原理</h4><p>master怎么知道slave与自己的数据差异在哪里呢?</p>
<p>这就要说到全量同步时的<code>repl_baklog</code>文件了。这个文件是一个固定大小的数组，只不过数组是环形，也就是说<strong>角标到达数组末尾后，会再次从0开始读写</strong>，这样数组头部的数据就会被覆盖</p>
<p><code>repl_baklog</code>中会记录Redis处理过的命令及<code>offset</code>，包括master当前的<code>offset</code>，和slave已经拷贝到的<code>offset</code>：</p>
<p><img src="/img/loading.gif" data-original="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1assests/ff94e95c-9492-46ec-bc5e-636acf41dd3c.png" alt="ff94e95c-9492-46ec-bc5e-636acf41dd3c"></p>
<p>slave与master的offset之间的差异，就是salve需要增量拷贝的数据了</p>
<p>随着不断有数据写入，master的offset逐渐变大，slave也不断的拷贝，追赶master的offset：</p>
<p><img src="/img/loading.gif" data-original="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1assests/f36883d0-5086-4287-ab9a-0ebe005559a5.png" alt="f36883d0-5086-4287-ab9a-0ebe005559a5"></p>
<p>直到数组被填满：</p>
<p><img src="/img/loading.gif" data-original="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1assests/7d29a7e9-0e6c-4630-9d48-0fccaafd1992.png" alt="7d29a7e9-0e6c-4630-9d48-0fccaafd1992"></p>
<p>此时，如果有新的数据写入，就会覆盖数组中的旧数据。不过，旧的数据只要是绿色的，说明是已经被同步到slave的数据，即便被覆盖了也没什么影响。因为未同步的仅仅是红色部分：</p>
<p><img src="/img/loading.gif" data-original="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1assests/ec2606a9-c80c-42af-a07e-ebb71b99b50a.png" alt="ec2606a9-c80c-42af-a07e-ebb71b99b50a"></p>
<p>但是，如果slave出现网络阻塞，导致master的<code>offset</code>远远超过了slave的<code>offset</code>： </p>
<p><img src="/img/loading.gif" data-original="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1assests/45278ff9-32bf-4eb1-9165-6c5dcc95435c.png" alt="45278ff9-32bf-4eb1-9165-6c5dcc95435c"></p>
<p>如果master继续写入新数据，master的<code>offset</code>就会覆盖<code>repl_baklog</code>中旧的数据，直到将slave现在的<code>offset</code>也覆盖：</p>
<p><img src="/img/loading.gif" data-original="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1assests/d9939d4d-a443-453e-8487-9182c1117f39.png" alt="d9939d4d-a443-453e-8487-9182c1117f39"></p>
<p>棕色框中的红色部分，就是尚未同步，但是却已经被覆盖的数据。此时如果slave恢复，需要同步，却发现自己的<code>offset</code>都没有了，无法完成增量同步了。只能做<strong>全量同步</strong></p>
<p><code>repl_baklog</code>大小有上限，写满后会覆盖最早的数据。如果slave断开时间过久，<font color='red'>导致尚未备份的数据被覆盖</font>，则无法基于<code>repl_baklog</code>做增量同步，只能再次全量同步</p>
<p><img src="/img/loading.gif" data-original="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1assests/redis_replication_backlog.gif" alt="redis_replication_backlog"></p>
<h3 id="主从同步优化"><a href="#主从同步优化" class="headerlink" title="主从同步优化"></a>主从同步优化</h3><p>主从同步可以保证主从数据的一致性，非常重要</p>
<p>可以从以下几个方面来优化Redis主从就集群：</p>
<ul>
<li>在master中配置<code>repl-diskless-sync  yes</code>启用无磁盘复制，避免全量同步时的磁盘IO<ul>
<li>tips：虽然Redis的数据是存在于内存中的，但默认情况下，主从复制时master会生成RDB临时文件并发送给slave，slave将该临时文件保存在磁盘后再读取并同步数据。而无磁盘复制就是不生成RDB文件，master直接将序列化数据发送给slave进行同步</li>
</ul>
</li>
<li>Redis单节点上的内存占用不要太大，减少RDB导致的过多磁盘IO（也就是减少单节点上保存的数据）</li>
<li>适当提高<code>repl_baklog</code>的大小，发现slave宕机时尽快实现故障恢复，尽可能避免全量同步<ul>
<li>tips：repl_backlog 存储在内存中，增大其大小会直接增加 Redis 内存占用</li>
</ul>
</li>
<li>限制一个master上的slave节点数量，如果实在是太多slave，则可以采用<code>主-从-从</code>链式结构，减少master压力</li>
</ul>
<p><code>主-从-从</code>架构图：</p>
<p><img src="/img/loading.gif" data-original="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1assests/c4f31e9a-8d55-42fa-bdaa-ba9578b21c0a.png" alt="c4f31e9a-8d55-42fa-bdaa-ba9578b21c0a"></p>
<p>简述全量同步和增量同步区别？</p>
<ul>
<li>全量同步：master将完整内存数据生成RDB，发送RDB到slave。后续命令则记录在repl_baklog，逐个发送给slave。</li>
<li>增量同步：slave提交自己的offset到master，master获取repl_baklog中从offset之后的命令给slave</li>
</ul>
<p>什么时候执行全量同步？</p>
<ul>
<li>slave节点第一次连接master节点时</li>
<li>slave节点断开时间太久，repl_baklog中的offset已经被覆盖时</li>
</ul>
<p>什么时候执行增量同步？</p>
<ul>
<li>slave节点断开又恢复，并且在<code>repl_baklog</code>中能找到offset时</li>
</ul>
<h1 id="Redis哨兵"><a href="#Redis哨兵" class="headerlink" title="Redis哨兵"></a>Redis哨兵</h1><h2 id="哨兵原理"><a href="#哨兵原理" class="headerlink" title="哨兵原理"></a>哨兵原理</h2><p>Redis提供了哨兵（Sentinel）机制来实现主从集群的自动故障恢复。哨兵的具体作用如下：</p>
<ul>
<li>监控：Sentinel会不断检查master和slave是否按预期工作</li>
<li>自动故障切换：如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后，<strong>依旧以新的master为主</strong></li>
<li>通知：当集群发生故障转移时，Sentinel会将最新节点角色信息推送给Redis的客户端</li>
</ul>
<p><img src="/img/loading.gif" data-original="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1assests/534bd447-686d-47f0-9dbe-2d8a92f9813c.png" alt="534bd447-686d-47f0-9dbe-2d8a92f9813c"></p>
<h3 id="服务状态监控"><a href="#服务状态监控" class="headerlink" title="服务状态监控"></a>服务状态监控</h3><p>Sentinel基于心跳机制检测服务状态，每隔一秒向集群的每个实例发送ping命令：</p>
<ul>
<li>主观下线：如果某Sentinel节点发现某实例<strong>未在规定时间响应</strong>，则认为该实例主观下线</li>
<li>客观下线：若超过指定数量（quorum）的sentinel都认为该实例主观下线，则该实例客观下线。<code>quorum值最好超过Sentinel实例数量的一半</code></li>
</ul>
<h3 id="选举新的master"><a href="#选举新的master" class="headerlink" title="选举新的master"></a>选举新的master</h3><p>一旦发现master故障，sentinel需要在slave中选择一个作为新的master，选择依据如下：</p>
<ul>
<li>首先会判断slave节点与master节点断开时间长短，如果超过指定值（down-after-milliseconds * 10）则会排除该slave节点<ul>
<li>简单来说，就是担心断开时间太久而导致slave数据不同步</li>
</ul>
</li>
<li>然后判断slave节点的slave-priority值，<strong>值越小优先级越高</strong>，如果是<strong>0则永远不参与选举</strong></li>
<li>如果slave-priority一样，则判断slave节点的offset值，<strong>越大则说明数据越新，优先级越高</strong></li>
<li>最后是判断slave节点的运行id（run-id）大小，越小优先级越高（本质就是随机挑选一个，属于兜底方案）</li>
</ul>
<h3 id="选举leader"><a href="#选举leader" class="headerlink" title="选举leader"></a>选举leader</h3><p>首先，Sentinel集群要选出一个执行<code>failover</code>的Sentinel节点，可以成为<code>leader</code>。要成为<code>leader</code>要满足两个条件：</p>
<ul>
<li>最先获得超过半数的投票</li>
<li>获得的投票数不小于<code>quorum</code>值</li>
</ul>
<p>而sentinel投票的原则有两条：</p>
<ul>
<li>优先投票给目前得票最多的</li>
<li>如果目前没有任何节点的票，就投给自己</li>
</ul>
<p>比如有3个sentinel节点，<code>s1</code>、<code>s2</code>、<code>s3</code>，假如<code>s2</code>先投票：</p>
<ul>
<li>此时发现没有任何人在投票，那就投给自己。<code>s2</code>得1票</li>
<li>接着<code>s1</code>和<code>s3</code>开始投票，发现目前<code>s2</code>票最多，于是也投给<code>s2</code>，<code>s2</code>得3票</li>
<li><code>s2</code>称为<code>leader</code>，开始故障转移</li>
</ul>
<p>不难看出，<strong>谁先投票，谁就会称为leader</strong>，那什么时候会触发投票呢？</p>
<p>答案是<strong>第一个确认master客观下线的人会立刻发起投票，一定会成为leader</strong></p>
<h3 id="如何实现故障转移"><a href="#如何实现故障转移" class="headerlink" title="如何实现故障转移"></a>如何实现故障转移</h3><p>当选中了其中一个slave为新的master后（例如slave1），故障转移的步骤如下：</p>
<ul>
<li>sentinel给备选的slave1节点发送<code>slaveof no one</code>命令，让该命令成为master</li>
<li>sentinel给所有其他slave发送<code>slaveof 192.168.150.101 7002</code>，让这些slave成为新master的从节点，开始从新的master上同步数据</li>
<li>最后，sentinel将故障节点标记为slave，当故障节点恢复后会自动成为新的master的slave节点</li>
</ul>
<p>流程图如下：</p>
<p><img src="/img/loading.gif" data-original="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1assests/c86216cd-cdaa-4f6f-b745-769d3b6261da.png" alt="c86216cd-cdaa-4f6f-b745-769d3b6261da"></p>
<p><img src="/img/loading.gif" data-original="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1assests/d9fb992c-1ff5-4c04-bfc7-f1c147ef0696.png" alt="d9fb992c-1ff5-4c04-bfc7-f1c147ef0696"></p>
<p><img src="/img/loading.gif" data-original="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1assests/c7c1a0c8-90f6-4658-b9a2-3b354edbec81.png" alt="c7c1a0c8-90f6-4658-b9a2-3b354edbec81"></p>
<p><img src="/img/loading.gif" data-original="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1assests/63a76737-bde5-40bf-a5b4-bcaf1c2ec60c.png" alt="63a76737-bde5-40bf-a5b4-bcaf1c2ec60c"></p>
<h2 id="搭建哨兵集群"><a href="#搭建哨兵集群" class="headerlink" title="搭建哨兵集群"></a>搭建哨兵集群</h2><p>首先，停掉之前的redis集群：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 老版本DockerCompose</span></span><br><span class="line">docker-compose down</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新版本Docker</span></span><br><span class="line">docker compose down</span><br></pre></td></tr></table></figure>



<p>然后，找到课前资料提供的sentinel.conf文件：</p>
<p><img src="/img/loading.gif" data-original="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1assests/45d9552c-f3ad-4cfd-b92c-ed8cbee66cd6.png" alt="45d9552c-f3ad-4cfd-b92c-ed8cbee66cd6"></p>
<p>其内容如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sentinel announce-ip <span class="string">&quot;192.168.150.101&quot;</span></span><br><span class="line">sentinel monitor hmaster 192.168.150.101 7001 2</span><br><span class="line">sentinel down-after-milliseconds hmaster 5000</span><br><span class="line">sentinel failover-timeout hmaster 60000</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li><code>sentinel announce-ip &quot;192.168.150.101&quot;</code>：声明当前sentinel的ip（需要改为自己的ip）</li>
<li><code>sentinel monitor hmaster 192.168.150.101 7001 2</code>：指定集群的主节点信息 <ul>
<li><code>hmaster</code>：主节点名称，自定义，任意写</li>
<li><code>192.168.150.101 7001</code>：主节点的ip和端口（需要改为自己的ip）</li>
<li><code>2</code>：认定<code>master</code>下线时的<code>quorum</code>值</li>
</ul>
</li>
<li><code>sentinel down-after-milliseconds hmaster 5000</code>：声明master节点超时多久后被标记下线</li>
<li><code>sentinel failover-timeout hmaster 60000</code>：在第一次故障转移失败后多久再次重试</li>
</ul>
<p>在虚拟机的<code>/root/redis</code>目录下新建3个文件夹：<code>s1</code>、<code>s2</code>、<code>s3</code>:</p>
<p><img src="/img/loading.gif" data-original="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1assests/aa7351bd-330c-4dc6-83d4-c5d84e8a8b68.png" alt="aa7351bd-330c-4dc6-83d4-c5d84e8a8b68"></p>
<p>将课前资料提供的<code>sentinel.conf</code>文件分别拷贝一份到3个文件夹中</p>
<p>接着修改<code>docker-compose.yaml</code>文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">r1:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:6.2.7</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">r1</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line">    <span class="attr">entrypoint:</span> [<span class="string">&quot;redis-server&quot;</span>, <span class="string">&quot;--port&quot;</span>, <span class="string">&quot;7001&quot;</span>]</span><br><span class="line">  <span class="attr">r2:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:6.2.7</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">r2</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line">    <span class="attr">entrypoint:</span> [<span class="string">&quot;redis-server&quot;</span>, <span class="string">&quot;--port&quot;</span>, <span class="string">&quot;7002&quot;</span>, <span class="string">&quot;--slaveof&quot;</span>, <span class="string">&quot;192.168.150.101&quot;</span>, <span class="string">&quot;7001&quot;</span>]</span><br><span class="line">  <span class="attr">r3:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:6.2.7</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">r3</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line">    <span class="attr">entrypoint:</span> [<span class="string">&quot;redis-server&quot;</span>, <span class="string">&quot;--port&quot;</span>, <span class="string">&quot;7003&quot;</span>, <span class="string">&quot;--slaveof&quot;</span>, <span class="string">&quot;192.168.150.101&quot;</span>, <span class="string">&quot;7001&quot;</span>]</span><br><span class="line">  <span class="attr">s1:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:6.2.7</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">s1</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/root/redis/s1:/etc/redis</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line">    <span class="attr">entrypoint:</span> [<span class="string">&quot;redis-sentinel&quot;</span>, <span class="string">&quot;/etc/redis/sentinel.conf&quot;</span>, <span class="string">&quot;--port&quot;</span>, <span class="string">&quot;27001&quot;</span>]</span><br><span class="line">  <span class="attr">s2:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:6.2.7</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">s2</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/root/redis/s2:/etc/redis</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line">    <span class="attr">entrypoint:</span> [<span class="string">&quot;redis-sentinel&quot;</span>, <span class="string">&quot;/etc/redis/sentinel.conf&quot;</span>, <span class="string">&quot;--port&quot;</span>, <span class="string">&quot;27002&quot;</span>]</span><br><span class="line">  <span class="attr">s3:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:6.2.7</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">s3</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/root/redis/s3:/etc/redis</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line">    <span class="attr">entrypoint:</span> [<span class="string">&quot;redis-sentinel&quot;</span>, <span class="string">&quot;/etc/redis/sentinel.conf&quot;</span>, <span class="string">&quot;--port&quot;</span>, <span class="string">&quot;27003&quot;</span>]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：视频中用的redis镜像是latest，目前镜像版本已更新，需要将docker-compose.yaml的redis镜像版本设置为6.2.7</p>
</blockquote>
<p>直接运行命令，启动集群：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="/img/loading.gif" data-original="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1assests/f40776c4-390c-4b92-b6de-6b9c6a4f5fe2.png" alt="f40776c4-390c-4b92-b6de-6b9c6a4f5fe2"></p>
<h3 id="演示failover"><a href="#演示failover" class="headerlink" title="演示failover"></a>演示failover</h3><p>连接<code>7001</code>这个<code>master</code>节点，然后通过命令让其休眠60秒，模拟宕机：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接7001这个master节点，通过sleep模拟服务宕机，60秒后自动恢复</span></span><br><span class="line">docker <span class="built_in">exec</span> -it r1 redis-cli -p 7001 DEBUG <span class="built_in">sleep</span> 60</span><br></pre></td></tr></table></figure>



<p>稍微等待一段时间后，会发现sentinel节点触发了<code>failover</code>：</p>
<p><img src="/img/loading.gif" data-original="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1assests/b190361c-0773-492c-a0ae-b8a352b2d8a6.png" alt="b190361c-0773-492c-a0ae-b8a352b2d8a6"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Sentinel的三个作用是什么？</p>
<ul>
<li>集群监控</li>
<li>故障恢复</li>
<li>状态通知</li>
</ul>
<p>Sentinel如何判断一个redis实例是否健康？</p>
<ul>
<li>每隔1秒发送一次ping命令，如果超过一定时间没有相向则认为是主观下线（<code>sdown</code>）</li>
<li>如果大多数sentinel都认为实例主观下线，则判定服务客观下线（<code>odown</code>）</li>
</ul>
<p>故障转移步骤有哪些？</p>
<ul>
<li>首先要在<code>sentinel</code>中选出一个<code>leader</code>，由leader执行<code>failover</code></li>
<li>选定一个<code>slave</code>作为新的<code>master</code>，执行<code>slaveof noone</code>，切换到master模式</li>
<li>然后让所有节点都执行<code>slaveof</code> 新master</li>
<li>修改故障节点配置，添加<code>slaveof</code> 新master</li>
</ul>
<p>sentinel选举leader的依据是什么？</p>
<ul>
<li>票数超过sentinel节点数量1半</li>
<li>票数超过quorum数量</li>
<li><strong>一般情况下最先发起failover的节点会当选</strong></li>
</ul>
<p>sentinel从slave中选取master的依据是什么？</p>
<ul>
<li>首先会判断slave节点与master节点断开时间长短，如果超过<code>down-after-milliseconds * 10</code>则会排除该slave节点</li>
<li>然后判断slave节点的<code>slave-priority</code>值，越小优先级越高，如果是0则永不参与选举（默认都是1）</li>
<li>如果<code>slave-prority</code>一样，则判断slave节点的<code>offset</code>值，越大说明数据越新，优先级越高</li>
<li>最后是判断slave节点的<code>run_id</code>大小，越小优先级越高（<code>通过info server可以查看run_id</code>）</li>
</ul>
<h2 id="RedisTemplate连接哨兵集群"><a href="#RedisTemplate连接哨兵集群" class="headerlink" title="RedisTemplate连接哨兵集群"></a>RedisTemplate连接哨兵集群</h2><p>分为三步：</p>
<ul>
<li>1）引入依赖</li>
<li>2）配置哨兵地址</li>
<li>3）配置读写分离</li>
</ul>
<h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><p>就是SpringDataRedis的依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="配置哨兵地址"><a href="#配置哨兵地址" class="headerlink" title="配置哨兵地址"></a>配置哨兵地址</h3><p>连接哨兵集群与传统单点模式不同，不再需要设置每一个redis的地址，而是直接指定哨兵地址：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">master:</span> <span class="string">hmaster</span> <span class="comment"># 集群名</span></span><br><span class="line">      <span class="attr">nodes:</span> <span class="comment"># 哨兵地址列表</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:27001</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:27002</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:27003</span></span><br></pre></td></tr></table></figure>



<h3 id="配置读写分离"><a href="#配置读写分离" class="headerlink" title="配置读写分离"></a>配置读写分离</h3><p>最后，还要配置读写分离，让java客户端将写请求发送到master节点，读请求发送到slave节点。定义一个bean即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> LettuceClientConfigurationBuilderCustomizer <span class="title function_">clientConfigurationBuilderCustomizer</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> clientConfigurationBuilder -&gt; clientConfigurationBuilder.readFrom(ReadFrom.REPLICA_PREFERRED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个bean中配置的就是读写策略，包括四种：</p>
<ul>
<li><code>MASTER</code>：从主节点读取</li>
<li><code>MASTER_PREFERRED</code>：优先从<code>master</code>节点读取，<code>master</code>不可用才读取<code>slave</code></li>
<li><code>REPLICA</code>：从<code>slave</code>节点读取</li>
<li><code>REPLICA_PREFERRED</code>：优先从<code>slave</code>节点读取，所有的<code>slave</code>都不可用才读取<code>master</code></li>
</ul>
<h1 id="Redis分片集群"><a href="#Redis分片集群" class="headerlink" title="Redis分片集群"></a>Redis分片集群</h1><p>主从和哨兵可以解决高可用、高并发读的问题。但是依然有两个问题没有解决：</p>
<ul>
<li>海量数据存储问题（单节点Redis不推荐配置过大内存）</li>
<li>高并发写的问题（单个主节点无法承受高并发写入）</li>
</ul>
<p>使用分片集群可以解决以上问题，分片集群特征：</p>
<ul>
<li>集群中有多个master，每个master保存不同数据</li>
<li>每个master都可以有多个slave节点</li>
<li>master之间通过ping检测彼此健康状态</li>
<li><strong>客户端请求可以访问集群任意节点，最终都会被转发到数据所在节点</strong></li>
</ul>
<img src="/img/loading.gif" data-original="/img/微服务assests/b37687d1-19dc-440d-8b79-a4af190770f2.jpg" alt="b37687d1-19dc-440d-8b79-a4af190770f2" style="zoom:50%;" />

<blockquote>
<p>虽然分片集群可以解决海量数据存储问题、高并发问题，但是缺点也很明显，就是架构过于庞大复杂而带来的成本上升。所以一般只有大型企业或项目才会采用这种方式</p>
</blockquote>
<h2 id="搭建分片集群"><a href="#搭建分片集群" class="headerlink" title="搭建分片集群"></a>搭建分片集群</h2><p>Redis分片集群最少也需要3个master节点，由于虚拟机性能有限，所以只给每个master配置1个slave，形成最小的分片集群：</p>
<img src="/img/loading.gif" data-original="/img/微服务assests/9adb9ff3-b113-452e-b806-434f582336e7.jpg" alt="9adb9ff3-b113-452e-b806-434f582336e7" style="zoom:67%;" />

<blockquote>
<p>对于标准的 Redis 分片集群部署，通常不需要额外配置哨兵，因为集群本身就提供了所需的高可用功能</p>
</blockquote>
<p>计划部署的节点信息如下：</p>
<table>
<thead>
<tr>
<th>容器名</th>
<th>角色</th>
<th>IP</th>
<th>映射端口</th>
</tr>
</thead>
<tbody><tr>
<td>r1</td>
<td>master</td>
<td>192.168.150.101</td>
<td>7001</td>
</tr>
<tr>
<td>r2</td>
<td>master</td>
<td>192.168.150.101</td>
<td>7002</td>
</tr>
<tr>
<td>r3</td>
<td>master</td>
<td>192.168.150.101</td>
<td>7003</td>
</tr>
<tr>
<td>r4</td>
<td>slave</td>
<td>192.168.150.101</td>
<td>7004</td>
</tr>
<tr>
<td>r5</td>
<td>slave</td>
<td>192.168.150.101</td>
<td>7005</td>
</tr>
<tr>
<td>r6</td>
<td>slave</td>
<td>192.168.150.101</td>
<td>7006</td>
</tr>
</tbody></table>
<h3 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h3><p>分片集群中的Redis节点必须开启集群模式，一般在配置文件中添加下面参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">port 7000</span><br><span class="line">cluster-enabled <span class="built_in">yes</span></span><br><span class="line">cluster-config-file nodes.conf</span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line">appendonly <span class="built_in">yes</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>cluster-enabled</code>：是否开启集群模式</li>
<li><code>cluster-config-file</code>：集群模式的配置文件名称，无需手动创建，由集群自动维护</li>
<li><code>cluster-node-timeout</code>：集群中节点之间心跳超时时间</li>
</ul>
<blockquote>
<p>一般搭建部署集群肯定是给每个节点都配置上述参数，不过考虑到我们计划用<code>docker-compose</code>部署，因此可以直接在启动命令中指定参数，偷个懒</p>
</blockquote>
<p>在虚拟机的<code>/root</code>目录下新建一个<code>redis-cluster</code>目录，然后在其中新建一个<code>docker-compose.yaml</code>文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">r1:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:6.2.7</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">r1</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line">    <span class="attr">entrypoint:</span> [<span class="string">&quot;redis-server&quot;</span>, <span class="string">&quot;--port&quot;</span>, <span class="string">&quot;7001&quot;</span>, <span class="string">&quot;--cluster-enabled&quot;</span>, <span class="string">&quot;yes&quot;</span>, <span class="string">&quot;--cluster-config-file&quot;</span>, <span class="string">&quot;node.conf&quot;</span>]</span><br><span class="line">  <span class="attr">r2:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:6.2.7</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">r2</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line">    <span class="attr">entrypoint:</span> [<span class="string">&quot;redis-server&quot;</span>, <span class="string">&quot;--port&quot;</span>, <span class="string">&quot;7002&quot;</span>, <span class="string">&quot;--cluster-enabled&quot;</span>, <span class="string">&quot;yes&quot;</span>, <span class="string">&quot;--cluster-config-file&quot;</span>, <span class="string">&quot;node.conf&quot;</span>]</span><br><span class="line">  <span class="attr">r3:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:6.2.7</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">r3</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line">    <span class="attr">entrypoint:</span> [<span class="string">&quot;redis-server&quot;</span>, <span class="string">&quot;--port&quot;</span>, <span class="string">&quot;7003&quot;</span>, <span class="string">&quot;--cluster-enabled&quot;</span>, <span class="string">&quot;yes&quot;</span>, <span class="string">&quot;--cluster-config-file&quot;</span>, <span class="string">&quot;node.conf&quot;</span>]</span><br><span class="line">  <span class="attr">r4:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:6.2.7</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">r4</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line">    <span class="attr">entrypoint:</span> [<span class="string">&quot;redis-server&quot;</span>, <span class="string">&quot;--port&quot;</span>, <span class="string">&quot;7004&quot;</span>, <span class="string">&quot;--cluster-enabled&quot;</span>, <span class="string">&quot;yes&quot;</span>, <span class="string">&quot;--cluster-config-file&quot;</span>, <span class="string">&quot;node.conf&quot;</span>]</span><br><span class="line">  <span class="attr">r5:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:6.2.7</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">r5</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line">    <span class="attr">entrypoint:</span> [<span class="string">&quot;redis-server&quot;</span>, <span class="string">&quot;--port&quot;</span>, <span class="string">&quot;7005&quot;</span>, <span class="string">&quot;--cluster-enabled&quot;</span>, <span class="string">&quot;yes&quot;</span>, <span class="string">&quot;--cluster-config-file&quot;</span>, <span class="string">&quot;node.conf&quot;</span>]</span><br><span class="line">  <span class="attr">r6:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:6.2.7</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">r6</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line">    <span class="attr">entrypoint:</span> [<span class="string">&quot;redis-server&quot;</span>, <span class="string">&quot;--port&quot;</span>, <span class="string">&quot;7006&quot;</span>, <span class="string">&quot;--cluster-enabled&quot;</span>, <span class="string">&quot;yes&quot;</span>, <span class="string">&quot;--cluster-config-file&quot;</span>, <span class="string">&quot;node.conf&quot;</span>]</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：使用Docker部署Redis集群，network模式必须采用host</p>
</blockquote>
<h3 id="启动集群"><a href="#启动集群" class="headerlink" title="启动集群"></a>启动集群</h3><p>进入<code>/root/redis-cluster</code>目录，使用命令启动redis：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>



<p>启动成功，可以通过命令查看启动进程：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep redis</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">root       4822   4743  0 14:29 ?        00:00:02 redis-server *:7002 [cluster]</span><br><span class="line">root       4827   4745  0 14:29 ?        00:00:01 redis-server *:7005 [cluster]</span><br><span class="line">root       4897   4778  0 14:29 ?        00:00:01 redis-server *:7004 [cluster]</span><br><span class="line">root       4903   4759  0 14:29 ?        00:00:01 redis-server *:7006 [cluster]</span><br><span class="line">root       4905   4775  0 14:29 ?        00:00:02 redis-server *:7001 [cluster]</span><br><span class="line">root       4912   4732  0 14:29 ?        00:00:01 redis-server *:7003 [cluster]</span><br></pre></td></tr></table></figure>

<p>可以发现每个redis节点都以cluster模式运行。不过节点与节点之间并未建立连接</p>
<p>接下来，使用命令创建集群：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入任意节点容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it r1 bash</span><br><span class="line"><span class="comment"># 然后，执行命令</span></span><br><span class="line">redis-cli --cluster create --cluster-replicas 1 \</span><br><span class="line">192.168.0.104:7001 192.168.0.104:7002 192.168.0.104:7003 \</span><br><span class="line">192.168.0.104:7004 192.168.0.104:7005 192.168.0.104:7006</span><br></pre></td></tr></table></figure>

<p>命令说明：</p>
<ul>
<li><code>redis-cli --cluster</code>：代表集群操作命令</li>
<li><code>create</code>：代表是创建集群</li>
<li><code>--cluster-replicas 1</code> ：指定集群中每个<code>master</code>的副本个数为1<ul>
<li>此时<code>节点总数 ÷ (replicas + 1)</code> 得到的就是<code>master</code>的数量<code>n</code>。因此节点列表中的前<code>n</code>个节点就是<code>master</code>，其它节点都是<code>slave</code>节点，随机分配到不同<code>master</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>ip地址注意修改为自己的虚拟机地址</p>
</blockquote>
<p>输入命令后控制台会弹出下面的信息：</p>
<img src="/img/loading.gif" data-original="/img/微服务assests/84d88852-4113-4cb9-b253-f672e71d705f.png" alt="84d88852-4113-4cb9-b253-f672e71d705f" style="zoom: 67%;" />

<p>这里展示了集群中<code>master</code>与<code>slave</code>节点分配情况，并询问你是否同意。节点信息如下：</p>
<ul>
<li><code>7001</code>是<code>master</code>，节点<code>id</code>后6位是<code>da134f</code></li>
<li><code>7002</code>是<code>master</code>，节点<code>id</code>后6位是<code>862fa0</code></li>
<li><code>7003</code>是<code>master</code>，节点<code>id</code>后6位是<code>ad5083</code></li>
<li><code>7004</code>是<code>slave</code>，节点<code>id</code>后6位是<code>391f8b</code>，认<code>ad5083</code>（7003）为<code>master</code></li>
<li><code>7005</code>是<code>slave</code>，节点<code>id</code>后6位是<code>e152cd</code>，认<code>da134f</code>（7001）为<code>master</code></li>
<li><code>7006</code>是<code>slave</code>，节点<code>id</code>后6位是<code>4a018a</code>，认<code>862fa0</code>（7002）为<code>master</code></li>
</ul>
<p>输入<code>yes</code>然后回车。会发现集群开始创建，并输出下列信息：</p>
<img src="/img/loading.gif" data-original="/img/微服务assests/f003a764-46c3-4b7e-af03-2b1f5effa168.png" alt="f003a764-46c3-4b7e-af03-2b1f5effa168" style="zoom: 67%;" />



<p>接着，可以通过命令查看集群状态：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 7001 cluster nodes</span><br></pre></td></tr></table></figure>



<p>结果：</p>
<p><img src="/img/loading.gif" data-original="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1assests/d2fb4194-0074-4c36-9094-f8a344b53959.png" alt="d2fb4194-0074-4c36-9094-f8a344b53959"></p>
<h2 id="散列插槽"><a href="#散列插槽" class="headerlink" title="散列插槽"></a>散列插槽</h2><p>在Redis集群中，共有16384个hash slots，集群中的每一个master节点都会分配一定数量的hash slots：</p>
<p><img src="/img/loading.gif" data-original="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1assests/79d26d13-443d-4e46-8324-0369a1b703c8.png" alt="79d26d13-443d-4e46-8324-0369a1b703c8"></p>
<p>数据要分片存储到不同的Redis节点，肯定需要有分片的依据，这样下次查询的时候才能知道去哪个节点查询。很多数据分片都会采用一致性hash算法。而Redis则是利用散列插槽（**<code>hash slot</code>**）的方式实现数据分片</p>
<p>Redis数据不是与节点绑定，而是与插槽slot绑定。当读写数据时，Redis基于CRC16算法对Key做hash运算，得到的结果与16384取余，就计算出了这个key的slot值，然后到slot所在的Redis节点执行读写操作</p>
<blockquote>
<p>Slot（插槽）：相当于书架上的位置编号<br>Key（键）：相当于书的完整书名<br>Value（值）：相当于书的具体内容</p>
</blockquote>
<p>Redis在计算key的hash值时是不一定根据整个key计算，分两种情况：</p>
<ul>
<li>当key中包含<code>&#123;&#125;</code>时，根据<code>&#123;&#125;</code>之间的字符串计算hash slot</li>
<li>当key中不包含<code>&#123;&#125;</code>时，则根据整个key字符串计算hash slot</li>
</ul>
<p>例如：</p>
<ul>
<li>key是<code>user</code>，则根据<code>user</code>来计算hash slot</li>
<li>key是<code>user:&#123;age&#125;</code>，则根据<code>age</code>来计算hash slot</li>
</ul>
<h3 id="分片集群建立连接测试"><a href="#分片集群建立连接测试" class="headerlink" title="分片集群建立连接测试"></a>分片集群建立连接测试</h3><p>先于<code>7001</code>建立连接进行测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it r1 bash</span><br><span class="line"><span class="comment"># 进入redis-cli</span></span><br><span class="line">redis-cli -p 7001</span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line"><span class="built_in">set</span> user jack</span><br></pre></td></tr></table></figure>

<p>会发现报错了：</p>
<p><img src="/img/loading.gif" data-original="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1assests/3d3fc161-164e-4ad4-9a48-f346f963be96.png" alt="3d3fc161-164e-4ad4-9a48-f346f963be96"></p>
<blockquote>
<p>提示信息：<code>MOVED 5474</code>，其实就是经过计算，得出<code>user</code>这个<code>key</code>的<code>hash slot</code> 是<code>5474</code>，而<code>5474</code>是在<code>7002</code>节点，不能在<code>7001</code>上写入！！</p>
</blockquote>
<p>这是因为连接的方式有问题，**<font color='red'>连接集群时，要加<code>-c</code>参数</font>**：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过7001连接集群</span></span><br><span class="line">redis-cli -c -p 7001</span><br><span class="line"><span class="comment"># 存入数据</span></span><br><span class="line"><span class="built_in">set</span> user jack</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="/img/loading.gif" data-original="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1assests/00865969-66ab-4c00-abbf-7d42c1792369.png" alt="00865969-66ab-4c00-abbf-7d42c1792369"></p>
<p>可以看到，客户端自动跳转到了<code>5474</code>这个<code>slot</code>所在的<code>7002</code>节点</p>
<p>现在，添加一个新的key，这次加上<code>&#123;&#125;</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 试一下key中带&#123;&#125;</span></span><br><span class="line"><span class="built_in">set</span> user:&#123;age&#125; 21</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再试一下key中不带&#123;&#125;</span></span><br><span class="line"><span class="built_in">set</span> age 20</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="/img/loading.gif" data-original="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1assests/26013284-43f9-4a51-af9d-cd58c40465fa.png" alt="26013284-43f9-4a51-af9d-cd58c40465fa"></p>
<p>可以看到<code>user:&#123;age&#125;</code>和<code>age</code>计算出的<code>slot</code>都是<code>741</code></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>Redis分片集群如何判断某个key应该在哪个实例？</p>
<ul>
<li>将16384个插槽分配到不同的实例</li>
<li>根据key计算哈希值，对16384取余</li>
<li>余数作为插槽，寻找插槽所在实例即可</li>
</ul>
<p>如何将同一类数据固定的保存在同一个Redis实例？</p>
<ul>
<li>Redis计算key的插槽值时会判断key中是否包含<code>&#123;&#125;</code>，如果有则基于<code>&#123;&#125;</code>内的字符计算插槽</li>
<li>数据的key中可以加入<code>&#123;类型&#125;</code>，例如key都以<code>&#123;typeId&#125;</code>为前缀，这样同类型数据计算的插槽一定相同</li>
</ul>
<h2 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h2><p>分片集群的节点之间会互相通过ping的方式做心跳检测，超时未回应的节点会被标记为下线状态。当发现master下线时，会将这个master的某个slave提升为master</p>
<p>先打开一个控制台窗口，利用命令监测集群状态：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch docker <span class="built_in">exec</span> -it r1 redis-cli -p 7001 cluster nodes</span><br></pre></td></tr></table></figure>

<p>命令前面的watch可以每隔一段时间刷新执行结果，方便实时监控集群状态变化</p>
<p>接着，利用命令让某个master节点休眠。比如这里让<code>7002</code>节点休眠，打开一个新的ssh控制台，输入下面命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it r2 redis-cli -p 7002 DEBUG <span class="built_in">sleep</span> 30</span><br></pre></td></tr></table></figure>



<p>可以观察到，集群发现7002宕机，标记为下线：</p>
<p><img src="/img/loading.gif" data-original="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1assests/77fbf8e5-ec13-44bd-9523-bbf3984caf98.png" alt="77fbf8e5-ec13-44bd-9523-bbf3984caf98"></p>
<p>过了一段时间后，7002原本的小弟7006变成了<code>master</code>：</p>
<p><img src="/img/loading.gif" data-original="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1assests/6f874fba-b144-4b8b-9a5e-addc19139708.png" alt="6f874fba-b144-4b8b-9a5e-addc19139708"></p>
<p>而7002被标记为<code>slave</code>，而且其<code>master</code>正好是7006，主从地位互换</p>
<h1 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h1><h2 id="RedisObject"><a href="#RedisObject" class="headerlink" title="RedisObject"></a>RedisObject</h2><p>Redis中的任意数据类型的键和值都会被封装为一个RedisObject，也叫做Redis对象，源码如下：</p>
<img src="/img/loading.gif" data-original="/img/微服务assests/7dbe3a8c-8cd3-4685-b720-6cdd6489d5c4.png" alt="7dbe3a8c-8cd3-4685-b720-6cdd6489d5c4" style="zoom:67%;" />

<p>可以看到整个结构体中并不包含真实的数据，仅仅是对象头信息，内存占用的大小为4+4+24+32+64 &#x3D; 128bit</p>
<p>也就是16字节，然后指针<code>ptr</code>指针指向的才是真实数据存储的内存地址。所以RedisObject的内存开销是很大的</p>
<p>属性中的<code>encoding</code>就是当前对象底层采用的<strong>数据结构</strong>或<strong>编码方式</strong>，可选的有11种之多：</p>
<table>
<thead>
<tr>
<th align="left"><strong>编号</strong></th>
<th align="left"><strong>编码方式</strong></th>
<th align="left"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">OBJ_ENCODING_RAW</td>
<td align="left">raw编码动态字符串</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">OBJ_ENCODING_INT</td>
<td align="left">long类型的整数的字符串</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">OBJ_ENCODING_HT</td>
<td align="left">hash表（也叫dict）</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">OBJ_ENCODING_ZIPMAP</td>
<td align="left">已废弃</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">OBJ_ENCODING_LINKEDLIST</td>
<td align="left">双端链表</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">OBJ_ENCODING_ZIPLIST</td>
<td align="left">压缩列表</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">OBJ_ENCODING_INTSET</td>
<td align="left">整数集合</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">OBJ_ENCODING_SKIPLIST</td>
<td align="left">跳表</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">OBJ_ENCODING_EMBSTR</td>
<td align="left">embstr编码的动态字符串</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">OBJ_ENCODING_QUICKLIST</td>
<td align="left">快速列表</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">OBJ_ENCODING_STREAM</td>
<td align="left">Stream流</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left">OBJ_ENCODING_LISTPACK</td>
<td align="left">紧凑列表</td>
</tr>
</tbody></table>
<p>Redis中的5种不同的数据类型采用的底层数据结构和编码方式如下：</p>
<table>
<thead>
<tr>
<th align="left"><strong>数据类型</strong></th>
<th align="left"><strong>编码方式</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">STRING</td>
<td align="left"><code>int</code>、<code>embstr</code>、<code>raw</code></td>
</tr>
<tr>
<td align="left">LIST</td>
<td align="left"><code>LinkedList和ZipList</code>(3.2以前)、<code>QuickList</code>（3.2以后）</td>
</tr>
<tr>
<td align="left">SET</td>
<td align="left"><code>intset</code>、<code>HT</code></td>
</tr>
<tr>
<td align="left">ZSET</td>
<td align="left"><code>ZipList</code>（7.0以前）、<code>Listpack</code>（7.0以后）、<code>HT</code>、<code>SkipList</code></td>
</tr>
<tr>
<td align="left">HASH</td>
<td align="left"><code>ZipList</code>（7.0以前）、<code>Listpack</code>（7.0以后）、<code>HT</code></td>
</tr>
</tbody></table>
<p>这些数据类型比较复杂，所以这里<strong>重点讲解几个面试会问</strong>的，其它的可以查看黑马程序员发布的Redis专业课程：</p>
<iframe src="//player.bilibili.com/player.html?isOutside=true&aid=766995956&bvid=BV1cr4y1671t&cid=584434958&p=145" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" height="500"></iframe>



<h2 id="SkipList"><a href="#SkipList" class="headerlink" title="SkipList"></a>SkipList</h2><p>SkipList（跳表）首先是链表，但与传统链表相比有几点差异：</p>
<ul>
<li>元素按照升序排列存储</li>
<li>节点可能包含多个指针，指针跨度不同</li>
</ul>
<p>传统链表只有指向前后元素的指针，因此只能顺序依次访问。如果查找的元素在链表中间，查询的效率会比较低。而SkipList则不同，它内部包含跨度不同的多级指针，可以跳跃查找链表中间的元素，效率非常高</p>
<p><img src="/img/loading.gif" data-original="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1assests/ac80d3af-c78d-4029-aa54-f917c6472b50.png" alt="ac80d3af-c78d-4029-aa54-f917c6472b50"></p>
<p>可以看到1号元素就有指向3、5、10的多个指针，查询时就可以跳跃查找。例如要找大小为14的元素，查找的流程是这样的：</p>
<p><img src="/img/loading.gif" data-original="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1assests/f3d744df-dfdd-4a2c-ad13-08e122ff648b.png" alt="f3d744df-dfdd-4a2c-ad13-08e122ff648b"></p>
<ul>
<li>首先找元素1节点最高级指针，也就是4级指针，起始元素大小为1，指针跨度为9，可以判断出目标元素大小为10。由于14比10大，肯定要从10这个元素向下接着找。</li>
<li>找到10这个元素，发现10这个元素的最高级指针跨度为5，判断出目标元素大小为15，大于14，需要判断下级指针</li>
<li>10这个元素的2级指针跨度为3，判断出目标元素为13，小于14，因此要基于元素13接着找</li>
<li>13这个元素最高级级指针跨度为2，判断出目标元素为15，比14大，需要判断下级指针</li>
<li>13的下级指针跨度为1，因此目标元素是14，刚好于目标一致，找到</li>
</ul>
<p>这种多级指针的查询方式就避免了传统链表的逐个遍历导致的查询效率下降问题。在<strong>对<font color='red'>有序数据</font>做随机查询和排序时效率非常高</strong></p>
<p>跳表的结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="comment">// 头尾节点指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="comment">// 节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    <span class="comment">// 最大的索引层级</span></span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>

<p>可以看到SkipList主要属性是header和tail，也就是头尾指针，因此它是支持双向遍历的</p>
<p>跳表中节点的结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    sds ele; <span class="comment">// 节点存储的字符串</span></span><br><span class="line">    <span class="type">double</span> score;<span class="comment">// 节点分数，排序、查找用</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span> <span class="comment">// 前一个节点指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span> <span class="comment">// 下一个节点指针</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> span; <span class="comment">// 索引跨度</span></span><br><span class="line">    &#125; level[]; <span class="comment">// 多级索引数组</span></span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>

<p>每个节点中都包含ele和score两个属性，其中score是得分，也就是节点排序的依据。ele则是节点存储的字符串数据指针</p>
<p>其内存结构如下（<font color='red'>重点关注这张图即可</font>）：</p>
<img src="/img/loading.gif" data-original="/img/微服务assests/16305dc2-6c59-4f6e-be4a-677198725e5a.png" alt="16305dc2-6c59-4f6e-be4a-677198725e5a" style="zoom:67%;" />



<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>SkipList的特点：</p>
<ul>
<li>跳跃表是一个有序的双向链表，每个节点都包含score和ele值，其中ele保存的就是实际的数据</li>
<li>节点按照score值排序，score值一样则按照ele字典排序</li>
<li>每个节点都可以包含多层指针，层数是1~32之间的随机数</li>
<li>不同层指针到下一个节点的跨度不同，层级越高跨度越大</li>
<li>增删改查效率与红黑树基本一致，实现却更简单。但空间复杂度更高</li>
</ul>
<h2 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h2><p>Redis源码中<code>zset</code>，也就是<code>SortedSet</code>的结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    dict *dict; <span class="comment">// dict，底层就是HashTable</span></span><br><span class="line">    zskiplist *zsl; <span class="comment">// 跳表</span></span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure>



<p>其内存结构如图：</p>
<p><img src="/img/loading.gif" data-original="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1assests/bd0dd136-7018-48d2-b039-6d8588058162.png" alt="bd0dd136-7018-48d2-b039-6d8588058162"></p>
<h3 id="面试相关"><a href="#面试相关" class="headerlink" title="面试相关"></a>面试相关</h3><p><strong>面试题</strong>：Redis的<code>SortedSet</code>底层的数据结构是怎样的？</p>
<p><strong>答</strong>：</p>
<ul>
<li>首先SortedSet需要能存储score和member值，而且要快捷的根据member查询score，因此底层有一个哈希表，以member为键（key），以score为值（value）</li>
<li>其次SortedSet还需要能根据score排序，因此底层还维护了一个跳表</li>
<li><strong>当需要根据member查询score时，就去哈希表中查询</strong></li>
<li><strong>当需要根据score排序查询时，则基于跳表查询</strong></li>
</ul>
<p>（简单理解：key-value相关操作就通过哈希表，值的直接操作通过跳表【不一定正确】）</p>
<p>加分项：因为SortedSet底层需要用到两种数据结构，对内存占用比较高。因此Redis底层会对SortedSet中的元素大小做判断。如果<strong>元素个数小于128</strong>且<strong>每个元素都小于64字节</strong>，SortedSet底层会采用<strong>ZipList</strong>，也就是<strong>压缩列表</strong>来代替<strong>HashTable</strong>和<strong>SkipList</strong></p>
<p>不过，<code>ZipList</code>存在连锁更新问题，因此而在Redis7.0版本以后，<code>ZipList</code>又被替换为<strong>Listpack</strong>（紧凑列表）。</p>
<h1 id="Redis内存回收"><a href="#Redis内存回收" class="headerlink" title="Redis内存回收"></a>Redis内存回收</h1><p>Redis之所以性能强，最主要的原因就是基于内存存储。然而单节点的Redis其内存大小不宜过大，会影响持久化或主从同步性能</p>
<p>可以通过修改redis.conf文件，添加下面的配置来配置Redis的最大内存：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">maxmemory</span> <span class="string">1gb</span></span><br></pre></td></tr></table></figure>

<p>当内存达到上限，就无法存储更多数据了。因此，Redis内部会有两套内存回收的策略：</p>
<ul>
<li>内存过期策略</li>
<li>内存淘汰策略</li>
</ul>
<h2 id="内存过期处理"><a href="#内存过期处理" class="headerlink" title="内存过期处理"></a>内存过期处理</h2><h3 id="过期命令"><a href="#过期命令" class="headerlink" title="过期命令"></a>过期命令</h3><p>Redis提供了expire命令，给key设置TTL（Time-To-Live，存活时间）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写入一条数据</span></span><br><span class="line"><span class="built_in">set</span> num 123</span><br><span class="line"><span class="comment"># 设置20秒过期时间</span></span><br><span class="line">expire num 20</span><br></pre></td></tr></table></figure>

<p>不过set命令本身也可以支持过期时间的设置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">写入一条数据并设置20s过期时间</span></span><br><span class="line">set num EX 20</span><br></pre></td></tr></table></figure>

<p>当过期时间到了以后，再去查询数据，会发现数据已经不存在</p>
<h3 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h3><p>那么问题来了：</p>
<ul>
<li>Redis如何判断一个KEY是否过期呢？</li>
<li>Redis又是何时删除过期KEY的呢？</li>
</ul>
<p>Redis不管有多少种数据类型，本质是一个<code>KEY-VALUE</code>的键值型数据库，而这种键值映射底层正式基于HashTable来实现的，在Redis中叫做Dict</p>
<p>RedisDB的底层源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    dict dict;                 / The keyspace <span class="keyword">for</span> this DB , 也就是存放KEY和VALUE的哈希表*/</span><br><span class="line">    dict *expires;              <span class="comment">/* 同样是哈希表，但保存的是设置了TTL的KEY，及其到期时间*/</span></span><br><span class="line">    dict *blocking_keys;        <span class="comment">/* Keys with clients waiting for data (BLPOP)*/</span></span><br><span class="line">    dict *ready_keys;           <span class="comment">/* Blocked keys that received a PUSH */</span></span><br><span class="line">    dict *watched_keys;         <span class="comment">/* WATCHED keys for MULTI/EXEC CAS /</span></span><br><span class="line"><span class="comment">    int id;                     / Database ID, 0 ~ 15 /</span></span><br><span class="line"><span class="comment">    long long avg_ttl;          / Average TTL, just for stats /</span></span><br><span class="line"><span class="comment">    unsigned long expires_cursor; / Cursor of the active expire cycle. */</span></span><br><span class="line">    <span class="built_in">list</span> *defrag_later;         <span class="comment">/* List of key names to attempt to defrag one by one, gradually. */</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>

<p>现在回答第一个问题：</p>
<p><strong>面试题</strong>：Redis如何判断KEY是否过期呢？</p>
<p><strong>答</strong>：在Redis中会有两个Dict，也就是HashTable，其中一个记录KEY-VALUE键值对，另一个记录KEY和过期时间。要判断一个KEY是否过期，只需要到记录过期时间的Dict中根据KEY查询即可。</p>
<p>第二问题：</p>
<p><strong>面试题</strong>：Redis是何时删除过期KEY的呢？</p>
<p>Redis并不会在KEY过期时立刻删除KEY，因为要实现这样的效果就必须给每一个过期的KEY设置时钟，并监控这些KEY的过期状态。无论对CPU还是内存都会带来极大的负担。</p>
<p>Redis的过期KEY删除策略有两种：</p>
<ul>
<li><strong>惰性删除</strong></li>
<li><strong>周期删除</strong></li>
</ul>
<h4 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h4><p>惰性删除：顾明思议就是过期后不会立刻删除。那在什么时候删除呢？</p>
<p>Redis会在每次<strong>访问KEY的时候判断当前KEY有没有设置过期时间</strong>，如果有，过期时间是否已经到期。对应的源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// db.c</span></span><br><span class="line"><span class="comment">// 寻找要执行写操作的key</span></span><br><span class="line">robj *<span class="title function_">lookupKeyWriteWithFlags</span><span class="params">(redisDb *db, robj *key, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查key是否过期，如果过期则删除</span></span><br><span class="line">    expireIfNeeded(db,key);</span><br><span class="line">    <span class="keyword">return</span> lookupKey(db,key,flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找要执行读操作的key</span></span><br><span class="line">robj *<span class="title function_">lookupKeyReadWithFlags</span><span class="params">(redisDb *db, robj *key, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">    robj *val;</span><br><span class="line">    <span class="comment">// 检查key是否过期，如果过期则删除</span></span><br><span class="line">    <span class="keyword">if</span> (expireIfNeeded(db,key) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 略 ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    val = lookupKey(db,key,flags);</span><br><span class="line">    <span class="keyword">if</span> (val == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> keymiss;</span><br><span class="line">    server.stat_keyspace_hits++;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="周期删除"><a href="#周期删除" class="headerlink" title="周期删除"></a>周期删除</h4><p><strong>周期删除</strong>：顾明思议是通过一个定时任务，周期性的<strong>抽样</strong>部分过期的key，然后执行删除</p>
<p>执行周期有两种：</p>
<ul>
<li><strong>SLOW模式：</strong>Redis会设置一个定时任务<code>serverCron()</code>，按照<code>server.hz</code>的频率来执行过期key清理</li>
<li><strong>FAST模式：</strong>Redis的每个事件循环前执行过期key清理（事件循环就是NIO事件处理的循环）。</li>
</ul>
<p><strong>SLOW</strong>模式规则：</p>
<ul>
<li>① 执行频率受<code>server.hz</code>影响，默认为10，即每秒执行10次，每个执行周期100ms。</li>
<li>② 执行清理耗时不超过一次执行周期的25%，即25ms.</li>
<li>③ 逐个遍历db，逐个遍历db中的bucket，抽取20个key判断是否过期</li>
<li>④ 如果没达到时间上限（25ms）并且过期key比例大于10%，再进行一次抽样，否则结束</li>
</ul>
<p><strong>FAST</strong>模式规则（过期key比例小于10%不执行）：</p>
<ul>
<li>① 执行频率受<code>beforeSleep()</code>调用频率影响，但两次FAST模式间隔不低于2ms</li>
<li>② 执行清理耗时不超过1ms</li>
<li>③ 逐个遍历db，逐个遍历db中的bucket，抽取20个key判断是否过期</li>
<li>④ 如果没达到时间上限（1ms）并且过期key比例大于10%，再进行一次抽样，否则结束</li>
</ul>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>RedisKey的TTL记录方式：</p>
<ul>
<li>在RedisDB中通过一个哈希表记录每个Key的到期时间</li>
</ul>
<p>过期Key的删除策略：</p>
<ul>
<li>惰性删除：每次查找key时判断是否过期，如果过期则删除</li>
<li>周期删除：定期抽样部分key，判断是否过期，如果过期则删除</li>
</ul>
<p>周期删除的两种模式：</p>
<ol>
<li>SLOW模式执行频率默认为10，每次不超过25ms</li>
<li>FAST模式执行频率不固定，但两次间隔不低于2ms，每次耗时不超过1ms</li>
</ol>
<h2 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h2><p>对于某些特别依赖于Redis的项目而言，仅仅依靠过期KEY清理是不够的，内存可能很快就达到上限。因此Redis允许设置内存告警阈值，当内存使用达到阈值时就会主动挑选部分KEY删除以释放更多内存。这叫做<strong>内存淘汰</strong>机制</p>
<h3 id="内存淘汰时机"><a href="#内存淘汰时机" class="headerlink" title="内存淘汰时机"></a>内存淘汰时机</h3><p>那么问题来了，当内存达到阈值时执行内存淘汰，但问题是Redis什么时候会执去判断内存是否达到预警呢？</p>
<p>Redis<strong>每次执行任何命令</strong>时，都会判断内存是否达到阈值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.c中处理命令的部分源码</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">processCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    <span class="comment">// ... 略</span></span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory &amp;&amp; !server.lua_timedout) &#123;</span><br><span class="line">        <span class="comment">// 调用performEvictions()方法尝试进行内存淘汰</span></span><br><span class="line">        <span class="type">int</span> out_of_memory = (performEvictions() == EVICT_FAIL);</span><br><span class="line">        <span class="comment">// ... 略</span></span><br><span class="line">        <span class="keyword">if</span> (out_of_memory &amp;&amp; reject_cmd_on_oom) &#123;</span><br><span class="line">            <span class="comment">// 如果内存依然不足，直接拒绝命令</span></span><br><span class="line">            rejectCommand(c, shared.oomerr);</span><br><span class="line">            <span class="keyword">return</span> C_OK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h3><p>Redis支持8种不同的内存淘汰策略：</p>
<ul>
<li><code>noeviction</code>： 不淘汰任何key，但是内存满时不允许写入新数据，<strong>默认就是这种策略</strong></li>
<li><code>volatile-ttl</code>： 对设置了TTL的key，比较key的剩余TTL值，TTL越小越先被淘汰</li>
<li><code>allkeys-random</code>：对全体key ，随机进行淘汰。也就是直接从db-&gt;dict中随机挑选</li>
<li><code>volatile-random</code>：对设置了TTL的key ，随机进行淘汰。也就是从db-&gt;expires中随机挑选</li>
<li><code>allkeys-lru</code>： 对全体key，基于LRU算法进行淘汰</li>
<li><code>volatile-lru</code>： 对设置了TTL的key，基于LRU算法进行淘汰</li>
<li><code>allkeys-lfu</code>： 对全体key，基于LFU算法进行淘汰</li>
<li><code>volatile-lfu</code>： 对设置了TTL的key，基于LFU算法进行淘汰</li>
</ul>
<p>整理为表格：</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>策略名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>不淘汰</strong></td>
<td><code>noeviction</code></td>
<td>不淘汰任何 key，内存满时不允许写入新数据，默认策略</td>
</tr>
<tr>
<td><strong>随机淘汰</strong></td>
<td><code>allkeys-random</code></td>
<td>对全体 key，随机进行淘汰，直接从 <code>db-&gt;dict</code> 中随机挑选</td>
</tr>
<tr>
<td></td>
<td><code>volatile-random</code></td>
<td>对设置了 <code>TTL</code> 的 key，随机进行淘汰，从 <code>db-&gt;expires</code> 中随机挑选</td>
</tr>
<tr>
<td><strong>LRU算法</strong></td>
<td><code>allkeys-lru</code></td>
<td>对全体 key，基于 <code>LRU</code> 算法进行淘汰</td>
</tr>
<tr>
<td></td>
<td><code>volatile-lru</code></td>
<td>对设置了 <code>TTL</code> 的 key，基于 <code>LRU</code> 算法进行淘汰</td>
</tr>
<tr>
<td><strong>LFU算法</strong></td>
<td><code>allkeys-lfu</code></td>
<td>对全体 key，基于 <code>LFU</code> 算法进行淘汰</td>
</tr>
<tr>
<td></td>
<td><code>volatile-lfu</code></td>
<td>对设置了 <code>TTL</code> 的 key，基于 <code>LFU</code> 算法进行淘汰</td>
</tr>
<tr>
<td><strong>TTL优先</strong></td>
<td><code>volatile-ttl</code></td>
<td>对设置了 <code>TTL</code> 的 key，比较 key 的剩余 <code>TTL</code> 值，<code>TTL</code> 越小越先被淘汰</td>
</tr>
</tbody></table>
<blockquote>
<p>前缀为allkey：表示对所有的key进行操作</p>
<p>前缀为volatile：表示对设置了TTL的key进行操作</p>
</blockquote>
<p>比较容易混淆的有两个算法：</p>
<ul>
<li><strong>LRU</strong>（**<code>L</code><strong><code>east </code></strong><code>R</code><strong><code>ecently </code></strong><code>U</code><strong><code>sed</code>），</strong>最近最少未使用**。用<font color='red'>当前时间减去最后一次访问时间</font>，这个值越大则淘汰优先级越高</li>
<li><strong>LFU</strong>（**<code>L</code><strong><code>east </code></strong><code>F</code><strong><code>requently </code></strong><code>U</code><strong><code>sed</code>），</strong>最少频率使用**。会<font color='red'>统计每个key的访问频率</font>，值越小淘汰优先级越高</li>
</ul>
<p>Redis怎么知道某个KEY的<code>最近一次访问时间</code>或者是<code>访问频率</code>呢？</p>
<p>在Redis数据结构这一章，提到了RedisObject的结构：</p>
<p><img src="/img/loading.gif" data-original="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1assests/15bb52e9-f4dc-4233-86ad-4a331829975c.png" alt="15bb52e9-f4dc-4233-86ad-4a331829975c"></p>
<p>其中的<code>lru</code>就是记录最近一次访问时间和访问频率的。当然，你选择<code>LRU</code>和<code>LFU</code>时的记录方式不同：</p>
<ul>
<li><strong>LRU</strong>：以秒为单位记录最近一次访问时间，长度24bit</li>
<li><strong>LFU</strong>：高16位以分钟为单位记录最近一次访问时间，低8位记录逻辑访问次数</li>
</ul>
<p>时间就不说了，那么逻辑访问次数又是怎么回事呢？8位无符号数字最大才255，访问次数超过255怎么办？</p>
<p>这就要聊起Redis的<strong>逻辑访问次数</strong>算法了，LFU的访问次数之所以叫做<strong>逻辑访问次数</strong>，是因为并不是每次key被访问都计数，而是通过运算：</p>
<ul>
<li>① 生成<code>[0,1)</code>之间的随机数<code>R</code></li>
<li>② 计算 <code>1/(旧次数 * lfu_log_factor + 1)</code>，记录为<code>P</code>， <code>lfu_log_factor</code>默认为10</li>
<li>③ 如果 <code>R</code> &lt; <code>P </code>，则计数器 <code>+1</code>，且最大不超过255</li>
<li>④ 访问次数会随时间衰减，距离上一次访问时间每隔 <code>lfu_decay_time</code> 分钟(默认1) ，计数器<code>-1</code></li>
</ul>
<p>显然LFU的基于访问频率的统计更符合我们的淘汰目标，因此**<font color='red'>官方推荐使用LFU算法</font>**</p>
<p>不过这里大家要注意一下：Redis中的<code>KEY</code>可能有数百万甚至更多，每个KEY都有自己访问时间或者逻辑访问次数。要找出时间最早的或者访问次数最小的，难道要把Redis中<strong>所有数据排序</strong>？</p>
<p>要知道Redis的内存淘汰是在每次执行命令时处理的。如果每次执行命令都先对全量数据做内存排序，那命令的执行时长肯定会非常长，这是不现实的。</p>
<p>所以Redis采取的是<strong>抽样法</strong>，即每次抽样一定数量（<code>maxmemory_smples</code>）的key，然后基于内存策略做排序，找出淘汰优先级最高的，删除这个key。这就导致Redis的算法并不是真正的<strong>LRU</strong>，而是一种基于抽样的<strong>近似LRU算法</strong>。</p>
<p>不过，在Redis3.0以后改进了这个算法，引入了一个淘汰候选池，抽样的key要与候选池中的key比较淘汰优先级，优先级更高的才会被放入候选池。然后在候选池中找出优先级最高的淘汰掉，这就使算法的结果更接近与真正的LRU算法了。特别是在抽样值较高的情况下（例如10），可以达到与真正的LRU接近的效果。</p>
<p>这也是官方给出的真正LRU与近似LRU的结果对比：</p>
<p><img src="/img/loading.gif" data-original="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1assests/434628d3-6126-4a00-905d-00f8aeacedea.png" alt="434628d3-6126-4a00-905d-00f8aeacedea"></p>
<ul>
<li>浅灰色带是被驱逐的对象</li>
<li>灰色带是没有被驱逐的对象</li>
<li>绿色带是被添加的对象</li>
</ul>
<h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p><strong>面试题</strong>：<strong>Redis如何判断KEY是否过期呢？</strong></p>
<p><strong>答</strong>：在Redis中会有两个Dict，也就是HashTable，其中一个记录KEY-VALUE键值对，另一个记录KEY和过期时间。要判断一个KEY是否过期，只需要到记录过期时间的Dict中根据KEY查询即可。</p>
<p><strong>面试题</strong>：<strong>Redis何时删除过期KEY？如何删除？</strong></p>
<p><strong>答</strong>：Redis的过期KEY处理有两种策略，分别是惰性删除和周期删除。</p>
<p><strong>惰性删除</strong>是指在每次用户访问某个KEY时，判断KEY的过期时间：如果过期则删除；如果未过期则忽略。</p>
<p><strong>周期删除</strong>有两种模式：</p>
<ul>
<li><strong>SLOW</strong>模式：通过一个定时任务，定期的抽样部分带有TTL的KEY，判断其是否过期。默认情况下定时任务的执行频率是每秒10次，但每次执行不能超过25毫秒。如果执行抽样后发现时间还有剩余，并且过期KEY的比例较高，则会多次抽样。</li>
<li><strong>FAST</strong>模式：在Redis每次处理NIO事件之前，都会抽样部分带有TTL的KEY，判断是否过期，因此执行频率较高。但是每次执行时长不能超过1ms，如果时间充足并且过期KEY比例过高，也会多次抽样</li>
</ul>
<p><strong>面试题</strong>：<strong>当Redis内存不足时会怎么做</strong>？</p>
<p><strong>答</strong>：这取决于配置的内存淘汰策略，Redis支持很多种内存淘汰策略，例如LRU、LFU、Random. 但默认的策略是直接拒绝新的写入请求。而如果设置了其它策略，则会在每次执行命令后判断占用内存是否达到阈值。如果达到阈值则会基于配置的淘汰策略尝试进行内存淘汰，直到占用内存小于阈值为止。</p>
<p><strong>面试题</strong>：<strong>那你能聊聊LRU和LFU吗</strong>？</p>
<p><strong>答</strong>：<code>LRU</code>是最近最久未使用。Redis的Key都是RedisObject，当启用LRU算法后，Redis会在Key的头信息中使用24个bit记录每个key的最近一次使用的时间<code>lru</code>。每次需要内存淘汰时，就会抽样一部分KEY，找出其中空闲时间最长的，也就是<code>now - lru</code>结果最大的，然后将其删除。如果内存依然不足，就重复这个过程。</p>
<p>由于采用了抽样来计算，这种算法只能说是一种近似LRU算法。因此在Redis4.0以后又引入了<code>LFU</code>算法，这种算法是统计最近最少使用，也就是按key的访问频率来统计。当启用LFU算法后，Redis会在key的头信息中使用24bit记录最近一次使用时间和逻辑访问频率。其中高16位是以分钟为单位的最近访问时间，后8位是逻辑访问次数。与LFU类似，每次需要内存淘汰时，就会抽样一部分KEY，找出其中逻辑访问次数最小的，将其淘汰。</p>
<p><strong>面试题</strong>：<strong>逻辑访问次数是如何计算的</strong>？</p>
<p><strong>答</strong>：由于记录访问次数的只有<code>8bit</code>，即便是无符号数，最大值只有255，不可能记录真实的访问次数。因此Redis统计的其实是逻辑访问次数。这其中有一个计算公式，会根据当前的访问次数做计算，结果要么是次数<code>+1</code>，要么是次数不变。但随着当前访问次数越大，<code>+1</code>的概率也会越低，并且最大值不超过255.</p>
<p>除此以外，逻辑访问次数还有一个衰减周期，默认为1分钟，即每隔1分钟逻辑访问次数会<code>-1</code>。这样逻辑访问次数就能基本反映出一个<code>key</code>的访问热度了</p>
<h1 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h1><p>Redis经常被用作缓存，而缓存在使用的过程中存在很多问题需要解决。例如：</p>
<ul>
<li>缓存的数据一致性问题</li>
<li>缓存击穿</li>
<li>缓存穿透</li>
<li>缓存雪崩</li>
</ul>
<h2 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h2><p>缓存的通用模型有三种：</p>
<ul>
<li><code>Cache Aside</code>：由缓存调用者自己维护数据库与缓存的一致性。即：<ul>
<li>查询时：命中则直接返回，未命中则查询数据库并写入缓存</li>
<li>更新时：更新数据库并删除缓存，查询时自然会更新缓存</li>
</ul>
</li>
<li><code>Read/Write Through</code>：数据库自己维护一份缓存，底层实现对调用者透明。底层实现：<ul>
<li>查询时：命中则直接返回，未命中则查询数据库并写入缓存</li>
<li>更新时：判断缓存是否存在，不存在直接更新数据库。存在则更新缓存，同步更新数据库</li>
</ul>
</li>
<li><code>Write Behind Cahing</code>：读写操作都直接操作缓存，由线程异步的将缓存数据同步到数据库</li>
</ul>
<p>目前企业中使用最多的就是<code>Cache Aside</code>模式，因为实现起来非常简单。但缺点也很明显，就是<font color='red'>无法保证数据库与缓存的强一致性</font></p>
<blockquote>
<p>缓存指的就是Redis，数据库指的就是例如MySQL、SQL Server这种传统数据库</p>
</blockquote>
<p><code>Cache Aside</code>的写操作是要<strong>在更新数据库的同时删除缓存</strong>，那为什么不选择更新数据库的同时更新缓存，而是删除呢？</p>
<p>原因很简单，假如一段时间内无人查询，但是有多次更新，那这些更新都属于无效更新。采用删除方案也就是**<font color='red'>延迟更新</font>**，什么时候有人查询了，什么时候更新（相当于只有最后一次更新并查询的操作，才是有效更新）</p>
<blockquote>
<p>增删改操作中，只有删除操作才需要将Redis和数据库同时进行，而增和改只有在查询时才会同步数据库数据</p>
</blockquote>
<p>那到底是先更新数据库再删除缓存，还是先删除缓存再更新数据库呢？</p>
<p>现在假设有两个线程，一个来更新数据，一个来查询数据。分别分析两种策略的表现</p>
<p>先分析策略1，<strong>先更新数据库再删除缓存</strong>：</p>
<center><strong>正常情况</strong></center>

<p><img src="/img/loading.gif" data-original="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1assests/c3667631-6771-42ce-aac6-9f7f01bc801c.png" alt="c3667631-6771-42ce-aac6-9f7f01bc801c"></p>
<center><strong>异常情况</strong></center>

<p><img src="/img/loading.gif" data-original="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1assests/6b86e464-9dd2-49bb-a8a1-ca13846208f3.png" alt="6b86e464-9dd2-49bb-a8a1-ca13846208f3"></p>
<p>异常情况说明：</p>
<ul>
<li>线程1删除缓存后，还没来得及更新数据库，</li>
<li>此时线程2来查询，发现缓存未命中，于是查询数据库，写入缓存。由于此时数据库尚未更新，查询的是旧数据。也就是说刚才的删除白删了，缓存又变成旧数据了。</li>
<li>然后线程1更新数据库，此时数据库是新数据，<strong>缓存是旧数据</strong></li>
</ul>
<blockquote>
<p>由于更新数据库的操作本身比较耗时，在期间有线程来查询数据库并更新缓存的概率非常高。**<font color='red'>因此不推荐这种方案</font>**</p>
</blockquote>
<p>再来看策略2，先更新数据库再删除缓存：</p>
<center><strong>正常情况</strong></center>

<p><img src="/img/loading.gif" data-original="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1assests/0f2898e0-30c5-4dbd-abab-d8dce83222ba.png" alt="0f2898e0-30c5-4dbd-abab-d8dce83222ba"></p>
<center><strong>异常情况</strong></center>

<p><img src="/img/loading.gif" data-original="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1assests/ee43dc03-1653-43fc-892d-9b7ded54f345.png" alt="ee43dc03-1653-43fc-892d-9b7ded54f345"></p>
<p>异常情况说明：</p>
<ul>
<li>线程1查询缓存未命中，于是去查询数据库，查询到旧数据</li>
<li>线程1将数据写入缓存之前，线程2来了，更新数据库，删除缓存</li>
<li>线程1执行写入缓存的操作，<strong>写入旧数据</strong></li>
</ul>
<blockquote>
<p>可以发现，异常状态发生的<strong>概率极为苛刻</strong>，线程1必须是查询数据库已经完成，但是缓存尚未写入之前。线程2要完成更新数据库同时删除缓存的两个操作。要知道线程1执行写缓存的速度在毫秒之间，速度非常快，在这么短的时间要完成数据库和缓存的操作，概率非常之低</p>
</blockquote>
<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p><strong>综上</strong>，添加缓存的目的是为了提高系统性能，而要<strong>付出的代价就是缓存与数据库的强一致性</strong>。如果要求数据库与缓存的强一致，那就需要加锁避免并行读写。但这就降低了性能，与缓存的目标背道而驰。</p>
<p>因此不管任何缓存同步方案最终的目的都是<strong>尽可能保证最终一致性</strong>，降低发生不一致的概率。采用先更新数据库再删除缓存的方案，已经将这种概率降到足够低，目的已经达到了</p>
<p>缓存一致性策略的最佳实践方案：</p>
<ol>
<li>低一致性需求：使用Redis的Key过期清理方案</li>
<li>高一致性需求：主动更新，并以超时剔除作为兜底方案<ul>
<li>读操作：<ul>
<li>缓存命中则直接返回</li>
<li>缓存未命中则查询数据库，并写入缓存，设定超时时间</li>
</ul>
</li>
<li>写操作：<ul>
<li>先写入数据库，然后删除缓存</li>
<li>要确保数据库与缓存操作的原子性</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>当请求查询缓存未命中时，需要查询数据库以加载缓存。但是思考一下这样的场景：<strong>如果访问一个数据库中也不存在的数据。会出现什么现象？</strong></p>
<p>由于数据库中不存在该数据，那么缓存中肯定也不存在。因此不管请求该数据多少次，缓存永远不可能建立，<strong>请求永远会直达数据库</strong></p>
<p>假如有不怀好意的人，开启很多线程频繁的访问一个数据库中也不存在的数据。由于缓存不可能生效，那么所有的请求都访问数据库，可能就会导致数据库因过高的压力而宕机</p>
<p>常见的解决方案有两种：</p>
<ul>
<li>缓存空对象</li>
<li>布隆过滤</li>
</ul>
<h3 id="缓存空对象"><a href="#缓存空对象" class="headerlink" title="缓存空对象"></a>缓存空对象</h3><p>简单来说，就是当发现请求的数据即不存在于缓存，也不存在于数据库时，将空值缓存到Redis，避免频繁查询数据库。实现思路如下：</p>
<p><img src="/img/loading.gif" data-original="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1assests/a6529a2d-a5c1-4797-ae3a-4d9ccd615dfd.png" alt="a6529a2d-a5c1-4797-ae3a-4d9ccd615dfd"></p>
<p>优点：</p>
<ul>
<li>实现简单，维护方便（最常见的方案）</li>
</ul>
<p>缺点：</p>
<ul>
<li>额外的内存消耗（所以需要设置TTL，且TTL值较小）</li>
</ul>
<h3 id="布隆过滤"><a href="#布隆过滤" class="headerlink" title="布隆过滤"></a>布隆过滤</h3><p>布隆过滤是一种数据统计的<strong>算法</strong>，用于检索一个元素是否存在一个集合中</p>
<p>一般判断集合中是否存在元素，都会先把元素保存到类似于树、哈希表等数据结构中，然后利用这些结构查询效率高的特点来快速匹配判断。但是随着元素数量越来越多，这种模式对内存的占用也越来越大，检索的速度也会越来越慢。而布隆过滤的内存占用小，查询效率却很高（因为只需要判断数据是否存在，而不需要存储实际的数据）</p>
<p>布隆过滤首先需要一个很长的bit数组，默认数组中每一位都是0</p>
<p><img src="/img/loading.gif" data-original="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1assests/91037001-1aea-4656-a8bd-14553d009cd6.png" alt="91037001-1aea-4656-a8bd-14553d009cd6"></p>
<p>然后还需要<code>K</code>个<code>hash</code>函数，将元素基于这些hash函数做运算的结果映射到bit数组的不同位置，并将这些位置置为1，例如现在k&#x3D;3：</p>
<ul>
<li><code>hello</code>经过运算得到3个角标：1、5、12</li>
<li><code>world</code>经过运算得到3个角标：8、17、21</li>
<li><code>java</code>经过运算得到3个角标：17、25、28</li>
</ul>
<p>则需要将每个元素对应角标位置置为1：</p>
<p><img src="/img/loading.gif" data-original="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1assests/0364ef4b-4a54-4349-b573-d6c77238bbb3.png" alt="0364ef4b-4a54-4349-b573-d6c77238bbb3"></p>
<p>此时，要判断元素是否存在，只需要再次基于<code>K</code>个<code>hash</code>函数做运算， 得到<code>K</code>个角标，判断每个角标的位置是不是1：</p>
<ul>
<li>只要全是1，就证明元素存在</li>
<li>任意位置为0，就证明元素一定不存在</li>
</ul>
<p>假如某个元素本身并不存在，也没添加到布隆过滤器过。但是<strong>由于存在hash碰撞的可能性</strong>，这就会出现这个元素计算出的角标已经被其它元素置为1的情况。那么这个元素也会被误判为已经存在。</p>
<p>因此，布隆过滤器的判断存在误差：</p>
<ul>
<li>当布隆过滤器认为元素不存在时，它<strong>肯定不存在</strong></li>
<li>当布隆过滤器认为元素存在时，它<strong>可能存在，也可能不存在</strong></li>
</ul>
<blockquote>
<p>也正是因为不存的元素一定不存在，所以即使有恶意攻击不存在的数据，也不会导致缓存穿透</p>
</blockquote>
<p>当<code>bit</code>数组越大、<code>Hash</code>函数<code>K</code>越复杂，<code>K</code>越大时，这个误判的概率也就越低。由于采用<code>bit</code>数组来标示数据，即便<code>4,294,967,296</code>个<code>bit</code>位，也只占<code>512mb</code>的空间</p>
<p>可以把数据库中的数据利用布隆过滤器标记出来，当用户请求缓存未命中时，先基于布隆过滤器判断。如果不存在则直接拒绝请求，存在则去查询数据库。尽管布隆过滤存在误差，但一般都在0.01%左右，可以大大减少数据库压力</p>
<p>使用布隆过滤后的流程如下：</p>
<p><img src="/img/loading.gif" data-original="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1assests/f1bdbf65-9d1f-46fa-aa65-a4f7d48f57a9.png" alt="f1bdbf65-9d1f-46fa-aa65-a4f7d48f57a9"></p>
<p>最完美的方案就是将<strong>布隆过滤和缓存空对象两者结合</strong>：</p>
<ol>
<li>大部分情况下，布隆过滤器都可以正确判断数据的存在或不存在</li>
<li>当发生误判时（也就是说布隆过滤器认为数据存在，但是实际数据不存在），数据库中不存在数据，则缓存空对象并设置TTL值。这样即使攻击者发现了可以引起哈希碰撞的值，也有兜底方案去防范</li>
<li>而又因为哈希碰撞的概率极低，所以缓存空对象的数据也不会太多，可以大大减小内存压力</li>
</ol>
<p>但这种方案复杂度较高，适合大型企业或项目</p>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>缓存雪崩是指在<strong>同一时段</strong>大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力</p>
<p><img src="/img/loading.gif" data-original="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1assests/e9c678ef-fd04-4d5f-849e-0f5e67f05346.png" alt="e9c678ef-fd04-4d5f-849e-0f5e67f05346"></p>
<p>常见的解决方案有：</p>
<ul>
<li>给不同的Key的TTL添加随机值，这样KEY的过期时间不同，不会大量KEY同时过期</li>
<li>利用Redis集群提高服务的可用性，避免缓存服务宕机</li>
<li>给缓存业务添加降级限流策略</li>
<li>给业务添加多级缓存，比如先查询本地缓存，本地缓存未命中再查询Redis，Redis未命中再查询数据库。即便Redis宕机，也还有本地缓存可以抗压力</li>
</ul>
<blockquote>
<p>以上方案互不冲突，所以可以结合使用</p>
</blockquote>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存击穿问题也叫热点Key问题，就是一个<strong>高并发访问</strong>并且<strong>缓存重建业务较复杂</strong>的Key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击</p>
<p>由于采用的是<code>Cache Aside</code>模式，当缓存失效时需要下次查询时才会更新缓存。当某个key缓存失效时，如果这个key是热点key，并发访问量比较高。就会在一瞬间涌入大量请求，都发现缓存未命中，于是都会去查询数据库，尝试重建缓存。可能一瞬间就把数据库压垮了</p>
<p><img src="/img/loading.gif" data-original="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1assests/d2f35108-97a8-446f-bbd8-ed8035184f03.png" alt="d2f35108-97a8-446f-bbd8-ed8035184f03"></p>
<p>如上图所示：</p>
<ul>
<li>线程1发现缓存未命中，准备查询数据库，重建缓存，但是因为数据比较复杂，导致查询数据库耗时较久</li>
<li>在这个过程中，一下次来了3个新的线程，就都会发现缓存未命中，都去查询数据库</li>
<li>数据库压力激增</li>
</ul>
<p>常见的解决方案有两种：</p>
<ul>
<li>互斥锁：给重建缓存逻辑加锁，避免多线程同时指向</li>
<li>逻辑过期：热点key不要设置过期时间，在活动结束后手动删除</li>
</ul>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>基于互斥锁的方案如图：</p>
<p><img src="/img/loading.gif" data-original="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1assests/45f923bc-9121-4765-bfe2-bec9cc85b576.png" alt="45f923bc-9121-4765-bfe2-bec9cc85b576"></p>
<blockquote>
<p>互斥锁最明显的问题就是，当某个线程获得互斥锁后，其他线程需要等待该线程将数据写入缓存，导致性能下降</p>
</blockquote>
<h3 id="逻辑过期"><a href="#逻辑过期" class="headerlink" title="逻辑过期"></a>逻辑过期</h3><p>热点key不要设置过期时间，在活动结束后手动删除</p>
<p>逻辑过期的思路如图：</p>
<p><img src="/img/loading.gif" data-original="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1assests/f6860545-15f9-4ac7-9cec-0eead72c61d5.png" alt="f6860545-15f9-4ac7-9cec-0eead72c61d5"></p>
<blockquote>
<p>当获取锁失败后，<strong>不会进行等待而是直接返回旧数据</strong></p>
</blockquote>
<h3 id="方案总结"><a href="#方案总结" class="headerlink" title="方案总结"></a>方案总结</h3><table>
<thead>
<tr>
<th>解决方案</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>互斥锁</td>
<td>- 没有额外的内存消耗<br />- 保证一致性<br />- 实现简单</td>
<td>- 线程需要等待，性能受影响<br />- 可能有死锁风险</td>
</tr>
<tr>
<td>逻辑过期</td>
<td>- 线程无需等待，性能较好</td>
<td>- 不保证一致性<br />- 有额外内存消耗<br />- 实现复杂</td>
</tr>
</tbody></table>
<h2 id="缓存面试题总结"><a href="#缓存面试题总结" class="headerlink" title="缓存面试题总结"></a>缓存面试题总结</h2><p><strong>面试题</strong>：<strong>如何保证缓存的双写一致性</strong>？</p>
<p><strong>答</strong>：缓存的双写一致性很难保证强一致，只能尽可能降低不一致的概率，确保最终一致。我们项目中采用的是<code>Cache Aside</code>模式。简单来说，就是在更新数据库之后删除缓存；在查询时先查询缓存，如果未命中则查询数据库并写入缓存。同时我们会给缓存设置过期时间作为兜底方案，如果真的出现了不一致的情况，也可以通过缓存过期来保证最终一致。</p>
<p><strong>追问</strong>：为什么不采用延迟双删机制？</p>
<p><strong>答</strong>：延迟双删的第一次删除并没有实际意义，第二次采用延迟删除主要是解决数据库主从同步的延迟问题，我认为这是数据库主从的一致性问题，与缓存同步无关。既然主节点数据已经更新，Redis的缓存理应更新。而且延迟双删会增加缓存业务复杂度，也没能完全避免缓存一致性问题，投入回报比太低。</p>
<p><strong>面试题</strong>：<strong>如何解决缓存穿透问题</strong>？</p>
<p><strong>答</strong>：缓存穿透也可以说是穿透攻击，具体来说是因为请求访问到了数据库不存在的值，这样缓存无法命中，必然访问数据库。如果高并发的访问这样的接口，会给数据库带来巨大压力。</p>
<p>我们项目中都是基于布隆过滤器来解决缓存穿透问题的，当缓存未命中时基于布隆过滤器判断数据是否存在。如果不存在则不去访问数据库。</p>
<p>当然，也可以使用缓存空值的方式解决，不过这种方案比较浪费内存。</p>
<p><strong>面试题</strong>：<strong>如何解决缓存雪崩问题</strong>？</p>
<p><strong>答</strong>：缓存雪崩的常见原因有两个，第一是因为大量key同时过期。针对问这个题我们可以可以给缓存key设置不同的TTL值，避免key同时过期。</p>
<p>第二个原因是Redis宕机导致缓存不可用。针对这个问题我们可以利用集群提高Redis的可用性。也可以添加多级缓存，当Redis宕机时还有本地缓存可用。</p>
<p><strong>面试题</strong>：<strong>如何解决缓存击穿问题</strong>？</p>
<p><strong>答</strong>：缓存击穿往往是由热点Key引起的，当热点Key过期时，大量请求涌入同时查询，发现缓存未命中都会去访问数据库，导致数据库压力激增。解决这个问题的主要思路就是避免多线程并发去重建缓存，因此方案有两种。</p>
<p>第一种是基于互斥锁，当发现缓存未命中时需要先获取互斥锁，再重建缓存，缓存重建完成释放锁。这样就可以保证缓存重建同一时刻只会有一个线程执行。不过这种做法会导致缓存重建时性能下降严重。</p>
<p>第二种是基于逻辑过期，也就是不给热点Key设置过期时间，而是给数据添加一个过期时间的字段。这样热点Key就不会过期，缓存中永远有数据。</p>
<p>查询到数据时基于其中的过期时间判断key是否过期，如果过期开启独立新线程异步的重建缓存，而查询请求先返回旧数据即可。当然，这个过程也要加互斥锁，但由于重建缓存是异步的，而且获取锁失败也无需等待，而是返回旧数据，这样性能几乎不受影响。</p>
<p>需要注意的是，无论是采用哪种方式，在获取互斥锁后一定要再次判断缓存是否命中，做dubbo check. 因为当你获取锁成功时，可能是在你之前有其它线程已经重建缓存了。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Zhao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://norlcyan.netlify.app">https://norlcyan.netlify.app</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Norlcyan's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%90%8E%E7%AB%AF/">后端</a><a class="post-meta__tags" href="/tags/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/">非关系型数据库</a><a class="post-meta__tags" href="/tags/%E9%9B%86%E7%BE%A4/">集群</a><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/">面试相关</a><a class="post-meta__tags" href="/tags/%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/">缓存问题</a><a class="post-meta__tags" href="/tags/%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/">内存回收</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/archives/d48132d3.html" title="ElasticSearch"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-16</div><div class="title">ElasticSearch</div></div></a></div><div><a href="/archives/a5852a4a.html" title="性能优化-Redis数据库"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-15</div><div class="title">性能优化-Redis数据库</div></div></a></div><div><a href="/archives/2040d45d.html" title="Canal"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-16</div><div class="title">Canal</div></div></a></div><div><a href="/archives/8fe47ff4.html" title="JDBC"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-15</div><div class="title">JDBC</div></div></a></div><div><a href="/archives/8aee090c.html" title="接入华为云IOT平台"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-15</div><div class="title">接入华为云IOT平台</div></div></a></div><div><a href="/archives/65b69107.html" title="Nginx"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-15</div><div class="title">Nginx</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Zhao</div><div class="author-info__description">人生最遗憾的，莫过于，轻易地放弃了不该放弃的，固执地，坚持了不该坚持的。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">92</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">142</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Noober-jpg"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">如有侵权文章，可以加我QQ：3481765114通知我</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E4%B8%BB%E4%BB%8E"><span class="toc-number">1.</span> <span class="toc-text">Redis主从</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E9%9B%86%E7%BE%A4%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">主从集群结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E4%B8%BB%E4%BB%8E%E9%9B%86%E7%BE%A4"><span class="toc-number">1.2.</span> <span class="toc-text">搭建主从集群</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%A4%9A%E4%B8%AARedis%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">启动多个Redis实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E9%9B%86%E7%BE%A4"><span class="toc-number">1.2.2.</span> <span class="toc-text">建立集群</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-number">1.2.3.</span> <span class="toc-text">测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.</span> <span class="toc-text">主从同步原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E9%87%8F%E5%90%8C%E6%AD%A5"><span class="toc-number">1.3.1.</span> <span class="toc-text">全量同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5"><span class="toc-number">1.3.2.</span> <span class="toc-text">增量同步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#repl-baklog%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">repl_baklog原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E4%BC%98%E5%8C%96"><span class="toc-number">1.3.3.</span> <span class="toc-text">主从同步优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E5%93%A8%E5%85%B5"><span class="toc-number">2.</span> <span class="toc-text">Redis哨兵</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.</span> <span class="toc-text">哨兵原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%8A%B6%E6%80%81%E7%9B%91%E6%8E%A7"><span class="toc-number">2.1.1.</span> <span class="toc-text">服务状态监控</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E4%B8%BE%E6%96%B0%E7%9A%84master"><span class="toc-number">2.1.2.</span> <span class="toc-text">选举新的master</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E4%B8%BEleader"><span class="toc-number">2.1.3.</span> <span class="toc-text">选举leader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB"><span class="toc-number">2.1.4.</span> <span class="toc-text">如何实现故障转移</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E5%93%A8%E5%85%B5%E9%9B%86%E7%BE%A4"><span class="toc-number">2.2.</span> <span class="toc-text">搭建哨兵集群</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%94%E7%A4%BAfailover"><span class="toc-number">2.2.1.</span> <span class="toc-text">演示failover</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.2.2.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RedisTemplate%E8%BF%9E%E6%8E%A5%E5%93%A8%E5%85%B5%E9%9B%86%E7%BE%A4"><span class="toc-number">2.3.</span> <span class="toc-text">RedisTemplate连接哨兵集群</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="toc-number">2.3.1.</span> <span class="toc-text">引入依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E5%93%A8%E5%85%B5%E5%9C%B0%E5%9D%80"><span class="toc-number">2.3.2.</span> <span class="toc-text">配置哨兵地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="toc-number">2.3.3.</span> <span class="toc-text">配置读写分离</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4"><span class="toc-number">3.</span> <span class="toc-text">Redis分片集群</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4"><span class="toc-number">3.1.</span> <span class="toc-text">搭建分片集群</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE"><span class="toc-number">3.1.1.</span> <span class="toc-text">集群配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E9%9B%86%E7%BE%A4"><span class="toc-number">3.1.2.</span> <span class="toc-text">启动集群</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E6%8F%92%E6%A7%BD"><span class="toc-number">3.2.</span> <span class="toc-text">散列插槽</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E6%B5%8B%E8%AF%95"><span class="toc-number">3.2.1.</span> <span class="toc-text">分片集群建立连接测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">3.2.2.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB"><span class="toc-number">3.3.</span> <span class="toc-text">故障转移</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">4.</span> <span class="toc-text">Redis数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#RedisObject"><span class="toc-number">4.1.</span> <span class="toc-text">RedisObject</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SkipList"><span class="toc-number">4.2.</span> <span class="toc-text">SkipList</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">4.2.1.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SortedSet"><span class="toc-number">4.3.</span> <span class="toc-text">SortedSet</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3"><span class="toc-number">4.3.1.</span> <span class="toc-text">面试相关</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6"><span class="toc-number">5.</span> <span class="toc-text">Redis内存回收</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E8%BF%87%E6%9C%9F%E5%A4%84%E7%90%86"><span class="toc-number">5.1.</span> <span class="toc-text">内存过期处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%9C%9F%E5%91%BD%E4%BB%A4"><span class="toc-number">5.1.1.</span> <span class="toc-text">过期命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5"><span class="toc-number">5.1.2.</span> <span class="toc-text">过期策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%83%B0%E6%80%A7%E5%88%A0%E9%99%A4"><span class="toc-number">5.1.2.1.</span> <span class="toc-text">惰性删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E6%9C%9F%E5%88%A0%E9%99%A4"><span class="toc-number">5.1.2.2.</span> <span class="toc-text">周期删除</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">5.1.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-number">5.2.</span> <span class="toc-text">内存淘汰策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%97%B6%E6%9C%BA"><span class="toc-number">5.2.1.</span> <span class="toc-text">内存淘汰时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-number">5.2.2.</span> <span class="toc-text">淘汰策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-number">5.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98"><span class="toc-number">6.</span> <span class="toc-text">缓存问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">6.1.</span> <span class="toc-text">缓存一致性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-5"><span class="toc-number">6.1.1.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">6.2.</span> <span class="toc-text">缓存穿透</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.2.1.</span> <span class="toc-text">缓存空对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4"><span class="toc-number">6.2.2.</span> <span class="toc-text">布隆过滤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">6.3.</span> <span class="toc-text">缓存雪崩</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">6.4.</span> <span class="toc-text">缓存击穿</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">6.4.1.</span> <span class="toc-text">互斥锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%87%E6%9C%9F"><span class="toc-number">6.4.2.</span> <span class="toc-text">逻辑过期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93"><span class="toc-number">6.4.3.</span> <span class="toc-text">方案总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93"><span class="toc-number">6.5.</span> <span class="toc-text">缓存面试题总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/archives/4c776360.html" title="EasyExcel（报表导出）">EasyExcel（报表导出）</a><time datetime="2026-01-16T09:04:36.000Z" title="发表于 2026-01-16 17:04:36">2026-01-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/archives/30ee4bff.html" title="XXL-JOB">XXL-JOB</a><time datetime="2026-01-16T08:58:34.000Z" title="发表于 2026-01-16 16:58:34">2026-01-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/archives/27717283.html" title="Jmeter快速入门">Jmeter快速入门</a><time datetime="2026-01-16T08:43:23.000Z" title="发表于 2026-01-16 16:43:23">2026-01-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/archives/2040d45d.html" title="Canal">Canal</a><time datetime="2026-01-16T08:30:26.000Z" title="发表于 2026-01-16 16:30:26">2026-01-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/archives/d48132d3.html" title="ElasticSearch">ElasticSearch</a><time datetime="2026-01-16T08:30:26.000Z" title="发表于 2026-01-16 16:30:26">2026-01-16</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2026 By Zhao</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script src="/js/header_bg.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>